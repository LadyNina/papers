<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>An allocator-aware optional type</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	tab { padding-left: 2em; }
    tab2 { padding-left: 4em; }
	ins {color:#00A000}
	del {color:#A00000}
	</style>
</head>
<body>

<address align=right>
Document number: dxxxx
<br/>
Audience: LEWG
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
<a href="mailto:dinka.ranns@gmail.com">Nina Dinka Ranns</a><br/>
2019-08-19<br/>
</address>
<hr/>
<h1 align=center>An allocator-aware optional type</h1>

<h2>Abstract</h2>

<p>
  This is a proposal for an allocator-aware optional type. For users
  that use custom allocators, such a type is currently missing;
  pair and tuple support allocators, but an optional type is also
  deemed necessary, because some such users use optional types
  as container elements. Therefore, an allocator-aware optional
  type is necessary for the usual scoped-allocator use cases to work.
</p>
<p>
  In this proposal, we propose a separate optional type that
  works with a polymorphic allocator. The allocator is not
  part of the type in the sense that it's not a template parameter.
</p>

<h2>Rationale for a separate type</h2>

<p>
  An allocator-aware optional needs to store the allocator used
  for object creation. This is because an optional can be disengaged
  and re-engaged, so it needs to 'remember' the allocator used
  when it's re-engaged. Storing an allocator incurs space overhead,
  so we wish to avoid that overhead for types that are not allocator-aware.
  Therefore, we are not proposing changing std::optional, but instead
  adding a new std::pmr::optional that can handle allocator-aware
  types.
</p>

<h2>Rationale for using polymorphic allocators only</h2>

<p>
  The rationale for polymorphic allocators applies here in general.
  Allocator-aware optionals are interoperable even if they use
  different concrete allocators, because the concrete allocator
  doesn't change the type, nor does it change the size of the type.
</p>

<h2>In general, some remarks about triviality</h2>

<p>
  We propose std::pmr::optional being an alias template; if the element
  of the optional is not allocator-aware, the alias template aliases
  std::optional. Otherwise, it aliases an unspecified type that
  adds allocator parameters to optional's constructor overload set.
</p>
<p>
  When prototyping this proposal, we realized that an allocator-aware
  optional is never trivially copyable. Copy constructor and copy
  assignment always potentially invoke the allocator; these operations
  are never bitwise copies. Move operations aren't trivial either, because
  they may also end up doing uses-allocator construction.
</p>
<p>
  This was an implementation-based reason for having an allocator-aware
  type separate from the usual optional. All the complexity of conditional
  triviality is in std::optional, and std::pmr::optional's allocator-aware
  alias target has none of that. The interface of std::optional doesn't
  have allocator parameters, whereas the interface of the allocator-aware
  concrete optional always has them available.
</p>

<h2>Feedback item for LEWG: should the general alias and the
  concrete allocator-aware optional type both be exposed?</h2>

<p>
  This proposal doesn't expose the concrete allocator-aware optional
  type. std::pmr::optional aliases it, and we specify it, but we don't
  name it. Chances are that some users might want to use it as a named
  type, in order to reason about their code. Furthermore, it's somewhat
  questionable whether std::pmr::optional&lt;AllocAware&gt; and
  std::pmr::optional&lt;AllocUnaware&gt; should even share a name; the APIs
  are different, the semantics are different.
</p>
<p>
  The reason why we chose to do it the current proposed  way is that
  practical users   just want one vocabulary type that either does or
  doesn't do allocators, depending on the element type's properties.
  The users we've talked to didn't see much value in having a type
  that is always allocator-aware; instead, it's allocator-aware when
  it can be, and otherwise not.
</p>

<h2>Proposed wording</h2>
<p>
Add new paragraphs after 20.6.1/p1 [optional.general]
</p>
<p><blockquote><ins>[2] <tt>pmr::optional</tt> is an alias template such that for a type <tt>T</tt>, where
<tt>uses_allocator&lt;T, polymorphic_allocator&lt;&gt;&gt;</tt> is true, <tt>pmr::optional&lt;T&gt;</tt>
denotes a type which will construct the contained object with uses_allocator_construction 
<tt>[allocator.uses.construction]</tt> with an object of type <tt>polymorphic_allocator&lt;&gt;</tt>. 
Otherwise, the alias template denotes <tt>std::optional</tt>. </ins></blockquote></p>
<br/>
<p>
Insert new sections after 20.6.3 Class template optional [optional.optional]
</p>
<p><h3><ins> Class template domain_allocator_traits</ins></h3></p>
<p><blockquote><ins>
<code>
namespace pmr {
<br/><tab></tab>	template&lt;typename T&gt;
<br/><tab2></tab2> 	using optional = conditional_t&lt;uses_allocator&lt;T, polymorphic_allocator&lt;&gt;&gt;::value,
<br/><tab2/><tab2/><i>alloc-optional</i>&lt;T&gt; , std::optional&lt;T&gt;&gt;;
<br/>		  
<br/><tab/>  // [alloc-optional.optional], class template <t><i>alloc-optional</i></t> for exposition only
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>     class <i>alloc-optional</i>;
<br/>		  
 <br/><tab/>  // [optional.relops], relational operators
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator==(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator==(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator==(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator!=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator!=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator!=(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;=(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;=(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const std::optional&lt;T&gt;&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/>
<br/><tab/>  // [<i>alloc-optional</i>.nullops], comparison with nullopt
<br/><tab/>   template&lt;class T&gt; bool operator==(const <i>alloc-optional</i>&lt;T&gt;&amp;, nullopt_t) noexcept;
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>	strong_ordering operator&lt;=&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, nullopt_t) noexcept;
<br/>
 <br/><tab/> // [<i>alloc-optional</i>.comp.with.t], comparison with T
<br/><tab/>   template&lt;class T, class U&gt; bool operator==(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator==(const T&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator!=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator!=(const T&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;(const T&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;(const T&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;=(const T&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;=(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;=(const T&amp;, const <i>alloc-optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const <i>alloc-optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/>
 <br/><tab/> // [<i>alloc-optional</i>.specalg], specialized algorithms
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>    void swap(<i>alloc-optional</i>&lt;T&gt;&amp;, <i>alloc-optional</i>&lt;T&gt;&amp;) noexcept(see below);
<br/>
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>	optional&lt;<i/>see below</i>&gt; make_optional(T&amp;&amp;);
<br/><tab/>   template&lt;class T, class... Args>
<br/><tab2/>	optional&lt;T&gt; make_optional(Args&amp;&amp;... args);
<br/><tab/>   template&lt;class T, class U, class... Args>
<br/><tab2/>	optional&lt;T&gt; make_optional(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
<br/>
 <br/><tab/> // [<i>alloc-optional</i>.hash], hash support
<br/><tab/>   template&lt;class T&gt; struct hash&lt;<i>alloc-optional</i>&lt;T&gt;&gt;;
<br/>}
<br/> namespace std {
<br/><tab/> template&lt;typename T, typename _Alloc&gt;
 <br/><tab2/>   struct uses_allocator&lt;<i>alloc-optional</i>&lt;T&gt;, _Alloc&gt; : true_type {};
<br/>}
</code></ins></blockquote></p>

<p><h3><ins> Class template <i>alloc-optional</i></ins></h3></p>
<p><blockquote><ins>
<code>
namespace std::pmr {
 <br/><tab/>   template&lt;class T&gt;
<br/><tab/> class <i>alloc-optional</i> {
<br/><tab/> public:
<br/><tab2/> using value_type = T;
<br/>
<br/><tab2/>    // [<i>alloc-optional</i>.ctor], constructors
    <br/><tab2/><i>alloc-optional</i>() noexcept;
    <br/><tab2/><i>alloc-optional</i>(nullopt_t) noexcept;
    <br/><tab2/><i>alloc-optional</i>(const <i>alloc-optional</i>&amp;);
    <br/><tab2/><i>alloc-optional</i>(<i>alloc-optional</i>&amp;&amp;) noexcept(see below);
    <br/><tab2/>template&lt;class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc-optional</i>(in_place_t, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U, class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc-optional</i>(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U = T&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(U&amp;&amp;);
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(const <i>alloc-optional</i>&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(<i>alloc-optional</i>&lt;U&gt;&amp;&amp;);
	<br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(const std::optional&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(std::optional&lt;U&gt;&amp;&amp;);
      <br/>
    <br/><tab2/>// allocator-extended constructors  
    <br/><tab2/><i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;);
    <br/><tab2/><i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;, const <i>alloc-optional</i>&amp;);
    <br/><tab2/><i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;, <i>alloc-optional</i>&amp;&amp;) noexcept(see below);
    <br/><tab2/>template&lt;class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U, class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U = T&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;,U&amp;&amp;);
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;,const <i>alloc-optional</i>&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;,<i>alloc-optional</i>&lt;U&gt;&amp;&amp;);
	<br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;,const std::optional&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc-optional</i>(allocator_arg_t, const Alloc&amp;,std::optional&lt;U&gt;&amp;&amp;);  
<br/>
<br/><tab2/>    // [<i>alloc-optional</i>.dtor], destructor
<br/><tab2/>    ~<i>alloc-optional</i>();
<br/>
<br/><tab2/>    // [<i>alloc-optional</i>.assign], assignment
<br/><tab2/>    <i>alloc-optional</i>&amp; operator=(nullopt_t) noexcept;
<br/><tab2/>    <i>alloc-optional</i>&amp; operator=(const <i>alloc-optional</i>&amp;);
<br/><tab2/>    <i>alloc-optional</i>&amp; operator=(<i>alloc-optional</i>&amp;&amp;) noexcept(see below);
<br/><tab2/>    template&lt;class U = T&gt; <i>alloc-optional</i>&amp; operator=(U&amp;&amp;);
<br/><tab2/>    template&lt;class U&gt; <i>alloc-optional</i>&&amp;operator=(const <i>alloc-optional</i>&lt;U&gt;&amp;;
<br/><tab2/>    template&lt;class U&gt; <i>alloc-optional</i>&amp; operator=(<i>alloc-optional</i>&lt;U&gt;&amp;&amp;);
<br/><tab2/>    template&lt;class U&gt; <i>alloc-optional</i>&&amp;operator=(const std::optional&lt;U&gt;&amp;;
<br/><tab2/>    template&lt;class U&gt; <i>alloc-optional</i>&amp; operator=(std::optional&lt;U&gt;&amp;&amp;);
<br/><tab2/>    template&lt;class... Args&gt;> T&amp; emplace(Args&amp;&amp;...);
<br/><tab2/>    template&lt;class U, class... Args&gt; T&amp; emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/>
<br/><tab2/>    // [<i>alloc-optional</i>.swap], swap
<br/><tab2/>    void swap(<i>alloc-optional</i>&amp; noexcept(see below);
<br/>
<br/><tab2/>    // [<i>alloc-optional</i>.observe], observers
<br/><tab2/>    const T* operator-&gt;() const;
<br/><tab2/>    T* operator-&gt;();
<br/><tab2/>    const T&amp; operator*() const&amp;;
<br/><tab2/>    T&amp; operator*() &amp;;
<br/><tab2/>    T&amp;&amp; operator*() &amp;&amp;;
<br/><tab2/>    const T&amp;&amp; operator*() const&amp;&amp;;
<br/><tab2/>    explicit operator bool() const noexcept;
<br/><tab2/>    bool has_value() const noexcept;
<br/><tab2/>    const T&amp; value() const&amp;;
<br/><tab2/>    T&amp; value() &amp;;
<br/><tab2/>    T&amp;&amp; value() &amp;&amp;;
<br/><tab2/>    const T&amp;&amp; value() const&amp;&amp;;
<br/><tab2/>    template&lt;class U&gt; T value_or(U&amp;&amp;) const&amp;;
<br/><tab2/>    template&lt;class U&gt; T value_or(U&amp;&amp;) &amp;&amp;;
<br/>
 <br/><tab2/>   // [<i>alloc-optional</i>.mod], modifiers
<br/><tab2/>    void reset() noexcept;
<br/>
<br/><tab2/>  private:
<br/><tab2/><tab/>    T *val;         // exposition only
<br/><tab2/><tab/>    std::memory_resource *M_pmr;         // exposition only
<br/><tab/>  };
<br/>
<br/>/* todo CTAD */
<br/>
<br/>}
</code>
</ins></blockquote></p>
<blockquote><ins>Any instance of <i>alloc-optional</i>&lt;T&gt; at any given time either contains a value or does not contain a value. 
When an instance of <i>alloc-optional</i>&lt;T&gt; contains a value, it means that an object of type <tt>T</tt>, 
referred to as the <i>alloc-optional</i> object's contained value, 
is allocated within the storage of the <i>alloc-optional</i> object. Implementations are not permitted to use 
additional storage, such as dynamic memory, to allocate its contained value. The contained value shall be allocated in a 
region of the <i>alloc-optional</i>&lt;T&gt; storage suitably aligned for the type <tt>T</tt> and constructed with uses-allocator construction. 
When an object of type <i>alloc-optional</i>&lt;T&gt; is contextually 
converted to bool, the conversion returns true if the object contains a value; otherwise the conversion returns false.
</ins></blockquote>
<blockquote><ins>Member <tt>val</tt> is provided for exposition only. When an <i>alloc-optional</i>&lt;T&gt; 
object contains a value, val points to the contained value.
</ins></blockquote>
<blockquote><ins>Member <tt>M_pmr</tt> is provided for exposition only and points to the memory_resource passed to the uses-allocator construction when
creating the contained value.</tt>.
</ins></blockquote>
<blockquote><ins><tt>T</tt> shall be a type other than <tt><i>cv</i> in_­place_­t</tt>, <tt><i>cv</i> allocator_arg_­t</tt>, or <tt><i>cv</i> nullopt_­t</tt> 
that meets the <i>Cpp17Destructible</i> requirements (Table 30).</ins></blockquote>



<p><h3><ins> Constructors [<i>alloc-optional</i>.ctor]</ins></h3></p>
<p><blockquote><ins>
<code>optional() noexcept;</code>
<code>optional(nullopt_t) noexcept;</code>
<tab/><i>Ensures:</i> *this does not contain a value.
<tab/><i>Remarks:</i> No contained value is initialized. <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>.

🔗
optional(const optional& rhs);
3
#Effects: If rhs contains a value, initializes the contained value as if direct-non-list-initializing an object of type T with the expression *rhs.
4
#<i>Ensures:</i> bool(rhs) == bool(*this).
5
#Throws: Any exception thrown by the selected constructor of T.
6
#<i>Remarks:</i> This constructor shall be defined as deleted unless is_­copy_­constructible_­v<T> is true. If is_­trivially_­copy_­constructible_­v<T> is true, this constructor is trivial.
🔗
optional(optional&& rhs) noexcept(see below);
7
#Effects: If rhs contains a value, initializes the contained value as if direct-non-list-initializing an object of type T with the expression std​::​move(*rhs). bool(rhs) is unchanged.
8
#<i>Ensures:</i> bool(rhs) == bool(*this).
9
#Throws: Any exception thrown by the selected constructor of T.
10
#<i>Remarks:</i> The expression inside noexcept is equivalent to is_­nothrow_­move_­constructible_­v<T>. This constructor shall not participate in overload resolution unless is_­move_­constructible_­v<T> is true. If is_­trivially_­move_­constructible_­v<T> is true, this constructor is trivial.
🔗
template&lt;class... Args> explicit optional(in_place_t, Args&&... args);
11
#Effects: Initializes the contained value as if direct-non-list-initializing an object of type T with the arguments std​::​forward<Args>(args)....
12
#<i>Ensures:</i> *this contains a value.
13
#Throws: Any exception thrown by the selected constructor of T.
14
#<i>Remarks:</i> If T's constructor selected for the initialization is a constructor, this constructor shall be a constructor. This constructor shall not participate in overload resolution unless is_­constructible_­v<T, Args...> is true.
🔗
template&lt;class U, class... Args>
  explicit optional(in_place_t, initializer_list<U> il, Args&&... args);
15
#Effects: Initializes the contained value as if direct-non-list-initializing an object of type T with the arguments il, std​::​forward<Args>(args)....
16
#<i>Ensures:</i> *this contains a value.
17
#Throws: Any exception thrown by the selected constructor of T.
18
#<i>Remarks:</i> This constructor shall not participate in overload resolution unless is_­constructible_­v<T, initializer_­list<U>&, Args&&...> is true. If T's constructor selected for the initialization is a constructor, this constructor shall be a constructor.
🔗
template&lt;class U = T> explicit(see below) optional(U&& v);
19
#Effects: Initializes the contained value as if direct-non-list-initializing an object of type T with the expression std​::​forward<U>(v).
20
#<i>Ensures:</i> *this contains a value.
21
#Throws: Any exception thrown by the selected constructor of T.
22
#<i>Remarks:</i> If T's selected constructor is a constructor, this constructor shall be a constructor. This constructor shall not participate in overload resolution unless is_­constructible_­v<T, U&&> is true, is_­same_­v<remove_­cvref_­t<U>, in_­place_­t> is false, and is_­same_­v<remove_­cvref_­t<U>, optional> is false. The expression inside explicit is equivalent to:
!is_convertible_v<U, T>
🔗
template&lt;class U> explicit(see below) optional(const optional<U>& rhs);
23
#Effects: If rhs contains a value, initializes the contained value as if direct-non-list-initializing an object of type T with the expression *rhs.
24
#<i>Ensures:</i> bool(rhs) == bool(*this).
25
#Throws: Any exception thrown by the selected constructor of T.
26
#<i>Remarks:</i> This constructor shall not participate in overload resolution unless
(26.1)
is_­constructible_­v<T, const U&> is true,
(26.2)
is_­constructible_­v<T, optional<U>&> is false,
(26.3)
is_­constructible_­v<T, optional<U>&&> is false,
(26.4)
is_­constructible_­v<T, const optional<U>&> is false,
(26.5)
is_­constructible_­v<T, const optional<U>&&> is false,
(26.6)
is_­convertible_­v<optional<U>&, T> is false,
(26.7)
is_­convertible_­v<optional<U>&&, T> is false,
(26.8)
is_­convertible_­v<const optional<U>&, T> is false, and
(26.9)
is_­convertible_­v<const optional<U>&&, T> is false.
The expression inside explicit is equivalent to:
!is_convertible_v<const U&, T>
🔗
template&lt;class U> explicit(see below) optional(optional<U>&& rhs);
27
#Effects: If rhs contains a value, initializes the contained value as if direct-non-list-initializing an object of type T with the expression std​::​move(*rhs). bool(rhs) is unchanged.
28
#<i>Ensures:</i> bool(rhs) == bool(*this).
29
#Throws: Any exception thrown by the selected constructor of T.
30
#<i>Remarks:</i> This constructor shall not participate in overload resolution unless
(30.1)
is_­constructible_­v<T, U&&> is true,
(30.2)
is_­constructible_­v<T, optional<U>&> is false,
(30.3)
is_­constructible_­v<T, optional<U>&&> is false,
(30.4)
is_­constructible_­v<T, const optional<U>&> is false,
(30.5)
is_­constructible_­v<T, const optional<U>&&> is false,
(30.6)
is_­convertible_­v<optional<U>&, T> is false,
(30.7)
is_­convertible_­v<optional<U>&&, T> is false,
(30.8)
is_­convertible_­v<const optional<U>&, T> is false, and
(30.9)
is_­convertible_­v<const optional<U>&&, T> is false.
The expression inside explicit is equivalent to:
!is_convertible_v<U, T>
20.6.3.2 Destructor [optional.dtor]
🔗
~optional();
1
#Effects: If is_­trivially_­destructible_­v<T> != true and *this contains a value, calls
val->T::~T()
2
#<i>Remarks:</i> If is_­trivially_­destructible_­v<T> is true, then this destructor is trivial.
20.6.3.3 Assignment [optional.assign]
🔗
optional<T>& operator=(nullopt_t) noexcept;
1
#Effects: If *this contains a value, calls val->T​::​~T() to destroy the contained value; otherwise no effect.
2
#Returns: *this.
3
#<i>Ensures:</i> *this does not contain a value.
🔗
optional<T>& operator=(const optional& rhs);
4
#Effects: See Table 41.
Table 41: optional​::​operator=(const optional&) effects   [tab:optional.assign.copy]
*this contains a value	*this does not contain a value
rhs contains a value		assigns *rhs to the contained value	initializes the contained value as if direct-non-list-initializing an object of type T with *rhs
rhs does not contain a value		destroys the contained value by calling val->T​::​~T()	no effect
5
#Returns: *this.
6
#<i>Ensures:</i> bool(rhs) == bool(*this).
7
#<i>Remarks:</i> If any exception is thrown, the result of the expression bool(*this) remains unchanged. If an exception is thrown during the call to T's copy constructor, no effect. If an exception is thrown during the call to T's copy assignment, the state of its contained value is as defined by the exception safety guarantee of T's copy assignment. This operator shall be defined as deleted unless is_­copy_­constructible_­v<T> is true and is_­copy_­assignable_­v<T> is true. If is_­trivially_­copy_­constructible_­v<T> && is_­trivially_­copy_­assignable_­v<T> && is_­trivially_­destructible_­v<T> is true, this assignment operator is trivial.
🔗
optional& operator=(optional&& rhs) noexcept(see below);
8
#Effects: See Table 42. The result of the expression bool(rhs) remains unchanged.
Table 42: optional​::​operator=(optional&&) effects   [tab:optional.assign.move]
*this contains a value	*this does not contain a value
rhs contains a value		assigns std​::​move(*rhs) to the contained value	initializes the contained value as if direct-non-list-initializing an object of type T with std​::​move(*rhs)
rhs does not contain a value		destroys the contained value by calling val->T​::​~T()	no effect
9
#Returns: *this.
10
#<i>Ensures:</i> bool(rhs) == bool(*this).
11
#<i>Remarks:</i> The expression inside noexcept is equivalent to:
is_nothrow_move_assignable_v<T> && is_nothrow_move_constructible_v<T>
12
#If any exception is thrown, the result of the expression bool(*this) remains unchanged. If an exception is thrown during the call to T's move constructor, the state of *rhs.val is determined by the exception safety guarantee of T's move constructor. If an exception is thrown during the call to T's move assignment, the state of *val and *rhs.val is determined by the exception safety guarantee of T's move assignment. This operator shall not participate in overload resolution unless is_­move_­constructible_­v<T> is true and is_­move_­assignable_­v<T> is true. If is_­trivially_­move_­constructible_­v<T> && is_­trivially_­move_­assignable_­v<T> && is_­trivially_­destructible_­v<T> is true, this assignment operator is trivial.
🔗
template&lt;class U = T> optional<T>& operator=(U&& v);
13
#Effects: If *this contains a value, assigns std​::​forward<U>(v) to the contained value; otherwise initializes the contained value as if direct-non-list-initializing object of type T with std​::​forward<U>(v).
14
#Returns: *this.
15
#<i>Ensures:</i> *this contains a value.
16
#<i>Remarks:</i> If any exception is thrown, the result of the expression bool(*this) remains unchanged. If an exception is thrown during the call to T's constructor, the state of v is determined by the exception safety guarantee of T's constructor. If an exception is thrown during the call to T's assignment, the state of *val and v is determined by the exception safety guarantee of T's assignment. This function shall not participate in overload resolution unless is_­same_­v<remove_­cvref_­t<U>, optional> is false, conjunction_­v<is_­scalar<T>, is_­same<T, decay_­t<U>>> is false, is_­constructible_­v<T, U> is true, and is_­assignable_­v<T&, U> is true.
🔗
template&lt;class U> optional<T>& operator=(const optional<U>& rhs);
17
#Effects: See Table 43.
Table 43: optional​::​operator=(const optional<U>&) effects   [tab:optional.assign.copy.templ]
*this contains a value	*this does not contain a value
rhs contains a value		assigns *rhs to the contained value	initializes the contained value as if direct-non-list-initializing an object of type T with *rhs
rhs does not contain a value		destroys the contained value by calling val->T​::​~T()	no effect
18
#Returns: *this.
19
#<i>Ensures:</i> bool(rhs) == bool(*this).
20
#<i>Remarks:</i> If any exception is thrown, the result of the expression bool(*this) remains unchanged. If an exception is thrown during the call to T's constructor, the state of *rhs.val is determined by the exception safety guarantee of T's constructor. If an exception is thrown during the call to T's assignment, the state of *val and *rhs.val is determined by the exception safety guarantee of T's assignment. This function shall not participate in overload resolution unless
(20.1)
is_­constructible_­v<T, const U&> is true,
(20.2)
is_­assignable_­v<T&, const U&> is true,
(20.3)
is_­constructible_­v<T, optional<U>&> is false,
(20.4)
is_­constructible_­v<T, optional<U>&&> is false,
(20.5)
is_­constructible_­v<T, const optional<U>&> is false,
(20.6)
is_­constructible_­v<T, const optional<U>&&> is false,
(20.7)
is_­convertible_­v<optional<U>&, T> is false,
(20.8)
is_­convertible_­v<optional<U>&&, T> is false,
(20.9)
is_­convertible_­v<const optional<U>&, T> is false,
(20.10)
is_­convertible_­v<const optional<U>&&, T> is false,
(20.11)
is_­assignable_­v<T&, optional<U>&> is false,
(20.12)
is_­assignable_­v<T&, optional<U>&&> is false,
(20.13)
is_­assignable_­v<T&, const optional<U>&> is false, and
(20.14)
is_­assignable_­v<T&, const optional<U>&&> is false.
🔗
template&lt;class U> optional<T>& operator=(optional<U>&& rhs);
21
#Effects: See Table 44. The result of the expression bool(rhs) remains unchanged.
Table 44: optional​::​operator=(optional<U>&&) effects   [tab:optional.assign.move.templ]
*this contains a value	*this does not contain a value
rhs contains a value		assigns std​::​move(*rhs) to the contained value	initializes the contained value as if direct-non-list-initializing an object of type T with std​::​move(*rhs)
rhs does not contain a value		destroys the contained value by calling val->T​::​~T()	no effect
22
#Returns: *this.
23
#<i>Ensures:</i> bool(rhs) == bool(*this).
24
#<i>Remarks:</i> If any exception is thrown, the result of the expression bool(*this) remains unchanged. If an exception is thrown during the call to T's constructor, the state of *rhs.val is determined by the exception safety guarantee of T's constructor. If an exception is thrown during the call to T's assignment, the state of *val and *rhs.val is determined by the exception safety guarantee of T's assignment. This function shall not participate in overload resolution unless
(24.1)
is_­constructible_­v<T, U> is true,
(24.2)
is_­assignable_­v<T&, U> is true,
(24.3)
is_­constructible_­v<T, optional<U>&> is false,
(24.4)
is_­constructible_­v<T, optional<U>&&> is false,
(24.5)
is_­constructible_­v<T, const optional<U>&> is false,
(24.6)
is_­constructible_­v<T, const optional<U>&&> is false,
(24.7)
is_­convertible_­v<optional<U>&, T> is false,
(24.8)
is_­convertible_­v<optional<U>&&, T> is false,
(24.9)
is_­convertible_­v<const optional<U>&, T> is false,
(24.10)
is_­convertible_­v<const optional<U>&&, T> is false,
(24.11)
is_­assignable_­v<T&, optional<U>&> is false,
(24.12)
is_­assignable_­v<T&, optional<U>&&> is false,
(24.13)
is_­assignable_­v<T&, const optional<U>&> is false, and
(24.14)
is_­assignable_­v<T&, const optional<U>&&> is false.
🔗
template&lt;class... Args> T& emplace(Args&&... args);
25
#Requires: is_­constructible_­v<T, Args&&...> is true.
26
#Effects: Calls *this = nullopt. Then initializes the contained value as if direct-non-list-initializing an object of type T with the arguments std​::​forward<Args>(args)....
27
#<i>Ensures:</i> *this contains a value.
28
#Returns: A reference to the new contained value.
29
#Throws: Any exception thrown by the selected constructor of T.
30
#<i>Remarks:</i> If an exception is thrown during the call to T's constructor, *this does not contain a value, and the previous *val (if any) has been destroyed.
🔗
template&lt;class U, class... Args> T& emplace(initializer_list<U> il, Args&&... args);
31
#Effects: Calls *this = nullopt. Then initializes the contained value as if direct-non-list-initializing an object of type T with the arguments il, std​::​forward<Args>(args)....
32
#<i>Ensures:</i> *this contains a value.
33
#Returns: A reference to the new contained value.
34
#Throws: Any exception thrown by the selected constructor of T.
35
#<i>Remarks:</i> If an exception is thrown during the call to T's constructor, *this does not contain a value, and the previous *val (if any) has been destroyed. This function shall not participate in overload resolution unless is_­constructible_­v<T, initializer_­list<U>&, Args&&...> is true.
20.6.3.4 Swap [optional.swap]
🔗
void swap(optional& rhs) noexcept(see below);
1
#Requires: Lvalues of type T shall be swappable and is_­move_­constructible_­v<T> is true.
2
#Effects: See Table 45.
Table 45: optional​::​swap(optional&) effects   [tab:optional.swap]
*this contains a value	*this does not contain a value
rhs contains a value		calls swap(*(*this), *rhs)	initializes the contained value of *this as if direct-non-list-initializing an object of type T with the expression std​::​move(*rhs), followed by rhs.val->T​::​~T(); postcondition is that *this contains a value and rhs does not contain a value
rhs does not contain a value		initializes the contained value of rhs as if direct-non-list-initializing an object of type T with the expression std​::​move(*(*this)), followed by val->T​::​~T(); postcondition is that *this does not contain a value and rhs contains a value	no effect
3
#Throws: Any exceptions thrown by the operations in the relevant part of Table 45.
4
#<i>Remarks:</i> The expression inside noexcept is equivalent to:
is_nothrow_move_constructible_v<T> && is_nothrow_swappable_v<T>
If any exception is thrown, the results of the expressions bool(*this) and bool(rhs) remain unchanged. If an exception is thrown during the call to function swap, the state of *val and *rhs.val is determined by the exception safety guarantee of swap for lvalues of T. If an exception is thrown during the call to T's move constructor, the state of *val and *rhs.val is determined by the exception safety guarantee of T's move constructor.
20.6.3.5 Observers [optional.observe]
🔗
const T* operator->() const;
T* operator->();
1
#Requires: *this contains a value.
2
#Returns: val.
3
#Throws: Nothing.
4
#<i>Remarks:</i> These functions shall be functions.
🔗
const T& operator*() const&;
T& operator*() &;
5
#Requires: *this contains a value.
6
#Returns: *val.
7
#Throws: Nothing.
8
#<i>Remarks:</i> These functions shall be functions.
🔗
T&& operator*() &&;
const T&& operator*() const&&;
9
#Requires: *this contains a value.
10
#Effects: Equivalent to: return std​::​move(*val);
🔗
explicit operator bool() const noexcept;
11
#Returns: true if and only if *this contains a value.
12
#<i>Remarks:</i> This function shall be a function.
🔗
bool has_value() const noexcept;
13
#Returns: true if and only if *this contains a value.
14
#<i>Remarks:</i> This function shall be a function.
🔗
const T& value() const&;
T& value() &;
15
#Effects: Equivalent to:
return bool(*this) ? *val : throw bad_optional_access();
🔗
T&& value() &&;
const T&& value() const&&;
16
#Effects: Equivalent to:
return bool(*this) ? std::move(*val) : throw bad_optional_access();
🔗
template&lt;class U> T value_or(U&& v) const&;
17
#Effects: Equivalent to:
return bool(*this) ? **this : static_cast<T>(std::forward<U>(v));
18
#<i>Remarks:</i> If is_­copy_­constructible_­v<T> && is_­convertible_­v<U&&, T> is false, the program is ill-formed.
🔗
template&lt;class U> T value_or(U&& v) &&;
19
#Effects: Equivalent to:
return bool(*this) ? std::move(**this) : static_cast<T>(std::forward<U>(v));
20
#<i>Remarks:</i> If is_­move_­constructible_­v<T> && is_­convertible_­v<U&&, T> is false, the program is ill-formed.
20.6.3.6 Modifiers [optional.mod]
🔗
void reset() noexcept;
1
#Effects: If *this contains a value, calls val->T​::​~T() to destroy the contained value; otherwise no effect.
2
#<i>Ensures:</i> *this does not contain a value.
</ins></blockquote></p>
</body>
</html>
