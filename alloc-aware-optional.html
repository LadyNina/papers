<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>An allocator-aware optional type</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	tab { padding-left: 2em; }
    tab2 { padding-left: 4em; }
	ins {background-color:#A0FFA0}
	del {background-color:#FFA0A0}
	</style>
</head>
<body>

<address align=right>
Document number: dxxxx
<br/>
Audience: LEWG
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
<a href="mailto:dinka.ranns@gmail.com">Nina Dinka Ranns</a><br/>
2019-08-19<br/>
</address>
<hr/>
<h1 align=center>An allocator-aware optional type</h1>

<h2>Abstract</h2>

<p>
  This is a proposal for an allocator-aware optional type. For users
  that use custom allocators, such a type is currently missing;
  pair and tuple support allocators, but an optional type is also
  deemed necessary, because some such users use optional types
  as container elements. Therefore, an allocator-aware optional
  type is necessary for the usual scoped-allocator use cases to work.
</p>
<p>
  In this proposal, we propose a separate optional type that
  works with a polymorphic allocator. The allocator is not
  part of the type in the sense that it's not a template parameter.
</p>

<h2>Rationale for a separate type</h2>

<p>
  An allocator-aware optional needs to store the allocator used
  for object creation. This is because an optional can be disengaged
  and re-engaged, so it needs to 'remember' the allocator used
  when it's re-engaged. Storing an allocator incurs space overhead,
  so we wish to avoid that overhead for types that are not allocator-aware.
  Therefore, we are not proposing changing std::optional, but instead
  adding a new std::pmr::optional that can handle allocator-aware
  types.
</p>

<h2>Rationale for using polymorphic allocators only</h2>

<p>
  The rationale for polymorphic allocators applies here in general.
  Allocator-aware optionals are interoperable even if they use
  different concrete allocators, because the concrete allocator
  doesn't change the type, nor does it change the size of the type.
</p>

<h2>In general, some remarks about triviality</h2>

<p>
  We propose std::pmr::optional being an alias template; if the element
  of the optional is not allocator-aware, the alias template aliases
  std::optional. Otherwise, it aliases an unspecified type that
  adds allocator parameters to optional's constructor overload set.
</p>
<p>
  When prototyping this proposal, we realized that an allocator-aware
  optional is never trivially copyable. Copy constructor and copy
  assignment always potentially invoke the allocator; these operations
  are never bitwise copies. Move operations aren't trivial either, because
  they may also end up doing uses-allocator construction.
</p>
<p>
  This was an implementation-based reason for having an allocator-aware
  type separate from the usual optional. All the complexity of conditional
  triviality is in std::optional, and std::pmr::optional's allocator-aware
  alias target has none of that. The interface of std::optional doesn't
  have allocator parameters, whereas the interface of the allocator-aware
  concrete optional always has them available.
</p>

<h2>Feedback item for LEWG: should the general alias and the
  concrete allocator-aware optional type both be exposed?</h2>

<p>
  This proposal doesn't expose the concrete allocator-aware optional
  type. std::pmr::optional aliases it, and we specify it, but we don't
  name it. Chances are that some users might want to use it as a named
  type, in order to reason about their code. Furthermore, it's somewhat
  questionable whether std::pmr::optional&lt;AllocAware&gt; and
  std::pmr::optional&lt;AllocUnaware&gt; should even share a name; the APIs
  are different, the semantics are different.
</p>
<p>
  The reason why we chose to do it the current proposed  way is that
  practical users   just want one vocabulary type that either does or
  doesn't do allocators, depending on the element type's properties.
  The users we've talked to didn't see much value in having a type
  that is always allocator-aware; instead, it's allocator-aware when
  it can be, and otherwise not.
</p>

<h2>Proposed wording</h2>
<p>
Add new paragraphs after 20.6.1/p1 [optional.general]
</p>
<p> <blockquote>
<ins>
[2] <tt>pmr::optional</tt> is an alias template such that for a type <tt>T</tt>, where
<tt>uses_allocator&lt;T, polymorphic_allocator&lt;&gt;&gt;</tt> is true, <tt>pmr::optional&lt;T&gt;</tt>
denotes a type which will construct the contained object with uses_allocator_construction 
<tt>[allocator.uses.construction]</tt> with an object of type <tt>polymorphic_allocator&lt;&gt;</tt>. 
Otherwise, the alias template denotes <tt>std::optional</tt>. </ins></p></blockquote>
<br/>
<p>
Insert new sections after 20.6.3 Class template optional [optional.optional]
</p>
<ins>
<p><h3><ins> Class template domain_allocator_traits</ins></h3>

<blockquote><ins><code>
namespace pmr {
<br/><tab></tab>	template&lt;typename T&gt;
<br/><tab2></tab2> 	using optional = conditional_t&lt;uses_allocator&lt;T, polymorphic_allocator&lt;&gt;&gt;::value,
<br/><tab2/><tab2/><i>alloc_optional</i>&lt;T&gt; , std::optional&lt;T&gt;&gt;;
<br/>		  
<br/><tab/>  // [alloc_optional.optional], class template <t><i>alloc_optional</i></t> for exposition only
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>     class <i>alloc_optional</i>;
<br/>		  
 <br/><tab/>  // [optional.relops], relational operators
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator==(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator==(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator==(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator!=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator!=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator!=(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&lt;=(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt;
<br/><tab2/>	bool operator&gt;=(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const std::optional&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const std::optional&lt;T&gt;&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/>
<br/><tab/>  // [<i>alloc_optional</i>.nullops], comparison with nullopt
<br/><tab/>   template&lt;class T&gt; bool operator==(const <i>alloc_optional</i>&lt;T&gt;&amp;, nullopt_t) noexcept;
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>	strong_ordering operator&lt;=&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, nullopt_t) noexcept;
<br/>
 <br/><tab/> // [<i>alloc_optional</i>.comp.with.t], comparison with T
<br/><tab/>   template&lt;class T, class U&gt; bool operator==(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator==(const T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator!=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator!=(const T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;(const T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;(const T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&lt;=(const T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;=(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/><tab/>   template&lt;class T, class U&gt; bool operator&gt;=(const T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab/>   template&lt;class T, three_way_comparable_with&lt;T&gt; U&gt;
<br/><tab2/>	compare_three_way_result_t&lt;T,U&gt;
<br/><tab/><tab2/>      operator&lt;=&gt;(const <i>alloc_optional</i>&lt;T&gt;&amp;, const U&amp;);
<br/>
 <br/><tab/> // [<i>alloc_optional</i>.specalg], specialized algorithms
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>    void swap(<i>alloc_optional</i>&lt;T&gt;&amp;, <i>alloc_optional</i>&lt;T&gt;&amp;) noexcept(see below);
<br/>
<br/><tab/>   template&lt;class T&gt;
<br/><tab2/>	optional&lt;<i/>see below</i>&gt; make_optional(T&amp;&amp;);
<br/><tab/>   template&lt;class T, class... Args>
<br/><tab2/>	optional&lt;T&gt; make_optional(Args&amp;&amp;... args);
<br/><tab/>   template&lt;class T, class U, class... Args>
<br/><tab2/>	optional&lt;T&gt; make_optional(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
<br/>
 <br/><tab/> // [<i>alloc_optional</i>.hash], hash support
<br/><tab/>   template&lt;class T&gt; struct hash&lt;<i>alloc_optional</i>&lt;T&gt;&gt;;
<br/>}
<br/> namespace std {
<br/><tab/> template&lt;typename T, typename _Alloc&gt;
 <br/><tab2/>   struct uses_allocator&lt;<i>alloc_optional</i>&lt;T&gt;, _Alloc&gt; : true_type {};
<br/>}
</code></ins></blockquote></p>

<p><h3><ins> Class template <i>alloc_optional</i></ins></h3></p>
<p>
<blockquote><ins>
<code>
namespace std::pmr {
 <br/><tab/>   template&lt;class T&gt;
<br/><tab/> class <i>alloc_optional</i> {
<br/><tab/> public:
<br/><tab2/> using value_type = T;
<br/>
<br/><tab2/>    // [<i>alloc_optional</i>.ctor], constructors
    <br/><tab2/><i>alloc_optional</i>() noexcept;
    <br/><tab2/><i>alloc_optional</i>(nullopt_t) noexcept;
    <br/><tab2/><i>alloc_optional</i>(const <i>alloc_optional</i>&amp;);
    <br/><tab2/><i>alloc_optional</i>(<i>alloc_optional</i>&amp;&amp;) noexcept(see below);
    <br/><tab2/>template&lt;class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc_optional</i>(in_place_t, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U, class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc_optional</i>(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U = T&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(U&amp;&amp;);
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(const <i>alloc_optional</i>&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(<i>alloc_optional</i>&lt;U&gt;&amp;&amp;);
	<br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(const std::optional&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(std::optional&lt;U&gt;&amp;&amp;);
      <br/>
    <br/><tab2/>// allocator-extended constructors  
    <br/><tab2/><i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;);
    <br/><tab2/><i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;, const <i>alloc_optional</i>&amp;);
    <br/><tab2/><i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;, <i>alloc_optional</i>&amp;&amp;) noexcept(see below);
    <br/><tab2/>template&lt;class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U, class... Args&gt;
      <br/><tab2/><tab/>explicit <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;, initializer_list&lt;U&gt;, Args&amp;&amp;...);
    <br/><tab2/>template&lt;class U = T&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;,U&amp;&amp;);
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;,const <i>alloc_optional</i>&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;,<i>alloc_optional</i>&lt;U&gt;&amp;&amp;);
	<br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;,const std::optional&lt;U&gt;&amp;;
    <br/><tab2/>template&lt;class U&gt;
      <br/><tab2/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp;,std::optional&lt;U&gt;&amp;&amp;);  
<br/>
<br/><tab2/>    // [<i>alloc_optional</i>.dtor], destructor
<br/><tab2/>    ~<i>alloc_optional</i>();
<br/>
<br/><tab2/>    // [<i>alloc_optional</i>.assign], assignment
<br/><tab2/>    <i>alloc_optional</i>&amp; operator=(nullopt_t) noexcept;
<br/><tab2/>    <i>alloc_optional</i>&amp; operator=(const <i>alloc_optional</i>&amp;);
<br/><tab2/>    <i>alloc_optional</i>&amp; operator=(<i>alloc_optional</i>&amp;&amp;) noexcept(see below);
<br/><tab2/>    template&lt;class U = T&gt; <i>alloc_optional</i>&amp; operator=(U&amp;&amp;);
<br/><tab2/>    template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(const <i>alloc_optional</i>&lt;U&gt;&amp;);
<br/><tab2/>    template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(<i>alloc_optional</i>&lt;U&gt;&amp;&amp;);
<br/><tab2/>    template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(const std::optional&lt;U&gt;&amp;;
<br/><tab2/>    template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(std::optional&lt;U&gt;&amp;&amp;);
<br/><tab2/>    template&lt;class... Args&gt;> T&amp; emplace(Args&amp;&amp;...);
<br/><tab2/>    template&lt;class U, class... Args&gt; T&amp; emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/>
<br/><tab2/>    // [<i>alloc_optional</i>.swap], swap
<br/><tab2/>    void swap(<i>alloc_optional</i>&amp; noexcept(see below);
<br/>
<br/><tab2/>    // [<i>alloc_optional</i>.observe], observers
<br/><tab2/>    const T* operator-&gt;() const;
<br/><tab2/>    T* operator-&gt;();
<br/><tab2/>    const T&amp; operator*() const&amp;;
<br/><tab2/>    T&amp; operator*() &amp;;
<br/><tab2/>    T&amp;&amp; operator*() &amp;&amp;;
<br/><tab2/>    const T&amp;&amp; operator*() const&amp;&amp;;
<br/><tab2/>    explicit operator bool() const noexcept;
<br/><tab2/>    bool has_value() const noexcept;
<br/><tab2/>    const T&amp; value() const&amp;;
<br/><tab2/>    T&amp; value() &amp;;
<br/><tab2/>    T&amp;&amp; value() &amp;&amp;;
<br/><tab2/>    const T&amp;&amp; value() const&amp;&amp;;
<br/><tab2/>    template&lt;class U&gt; T value_or(U&amp;&amp;) const&amp;;
<br/><tab2/>    template&lt;class U&gt; T value_or(U&amp;&amp;) &amp;&amp;;
<br/>
 <br/><tab2/>   // [<i>alloc_optional</i>.mod], modifiers
<br/><tab2/>    void reset() noexcept;
<br/>
<br/><tab2/>  private:
<br/><tab2/><tab/>    T *val;         // exposition only
<br/><tab2/><tab/>    std::memory_resource *M_pmr;         // exposition only
<br/><tab/>  };
<br/>
<br/>/* todo CTAD */
<br/>
<br/>}
</code>
</blockquote></ins></p>

<blockquote><ins>Any instance of <i>alloc_optional</i>&lt;T&gt; at any given time either contains a value or does not contain a value. 
When an instance of <i>alloc_optional</i>&lt;T&gt; contains a value, it means that an object of type <tt>T</tt>, 
referred to as the <i>alloc_optional</i> object's contained value, 
is allocated within the storage of the <i>alloc_optional</i> object. Implementations are not permitted to use 
additional storage, such as dynamic memory, to allocate its contained value. The contained value shall be allocated in a 
region of the <i>alloc_optional</i>&lt;T&gt; storage suitably aligned for the type <tt>T</tt> and constructed with uses-allocator construction. 
When an object of type <i>alloc_optional</i>&lt;T&gt; is contextually 
converted to bool, the conversion returns true if the object contains a value; otherwise the conversion returns false.
</ins></blockquote>
<blockquote><ins>Member <tt>val</tt> is provided for exposition only. When an <i>alloc_optional</i>&lt;T&gt; 
object contains a value, val points to the contained value.
</ins></blockquote>
<blockquote><ins>Member <tt>M_pmr</tt> is provided for exposition only and points to the memory_resource passed to the uses-allocator construction when
creating the contained value.</tt>.
</ins></blockquote>
<blockquote><ins><tt>T</tt> shall be a type other than <tt><i>cv</i> in_­place_­t</tt>, <tt><i>cv</i> allocator_arg_­t</tt>, or <tt><i>cv</i> nullopt_­t</tt> 
that meets the <i>Cpp17Destructible</i> requirements (Table 30).</ins></blockquote>



<p><h3><ins> Constructors [<i>alloc_optional</i>.ctor]</ins></h3></p>
<p><blockquote><ins>
<br/><code><i>alloc_optional</i>() noexcept;</code>
<br/><code><i>alloc_optional</i>(nullopt_t) noexcept;</code>
<br/><tab/><i>Effects:</i><tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>
<br/><tab/><i>Ensures:</i> *this does not contain a value.
<br/><tab/><i>Remarks:</i> No contained value is initialized.
<br/>
<br/><code><i>alloc_optional</i>(const <i>alloc_optional</i>&amp;);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and the expression <tt>*rhs</tt>
as the constructor argument.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall be defined as deleted unless <tt>is_­copy_­constructible_­v&lt;T&gt;</tt> is true.

<br/>
<br/><code><i>alloc_optional</i>(<i>alloc_optional</i>&amp;&amp; rhs) noexcept(see below)</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>std​::​move(*rhs)</tt> as the constructor argument. <tt>bool(rhs)</tt> is unchanged.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> The expression inside <tt>noexcept</tt> is equivalent to <tt>is_­nothrow_­move_­constructible_­v&lt;T&gt;</tt>. 
This constructor shall not participate in overload resolution unless <tt>is_­move_­constructible_­v&lt;T&gt;</tt> is true.


<br/>
<br/><code>template&lt;class... Args&gt; explicit <i>alloc_optional</i>(in_place_t, Args&amp;&amp;... args);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>std​::​forward&lt;Args&gt;(args)....</tt> as the constructor arguments. 
<br/><tab/><i>Ensures:</i> <tt>*this</tt> contains a value..
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless <tt>is_­copy_­constructible_­v&lt;T&gt;</tt> is true.

<br/>
<br/><code>template&lt;class... Args&gt; explicit <i>alloc_optional</i>(in_place_t, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>il, std​::​forward&lt;Args&gt;(args)....</tt> as the constructor arguments. 
<br/><tab/><i>Ensures:</i> <tt>*this</tt> contains a value..
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<tt>is_­constructible_­v&lt;T, initializer_­list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;</tt> is true.
  
<br/>
<br/><code>template&lt;class U = T&gt; explicit(see below) <i>alloc_optional</i>(U&amp;&amp; v);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt> std​::​forward&lt;U&gt;(v)</tt> as the constructor arguments. 
<br/><tab/><i>Ensures:</i> <tt>*this</tt> contains a value.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, U&amp;&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­same_­v&lt;remove_­cvref_­t&lt;U&gt;, in_­place_­t&gt</tt>
is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­same_­v&lt;remove_­cvref_­t&lt;U&gt;,<i>alloc_optional</i>&gt</tt> is <tt>false</tt>, and 
<br/><tab2/> - <tt>is_base_of_v&lt;memory_resource, remove_pointer_t&lt;remove_­cvref_­t&lt;U&gt;&gt;&gt;</tt> is <tt>false</tt>. 
<br/><tab/>The expression inside <tt>explicit</tt> is equivalent to:
<br/><tab2/><tt>!is_convertible_v&lt;U, T&gt;</tt> 

<br/>
<br/><code>template&lt;class U&gt; explicit(see below) <i>alloc_optional</i>(const <i>alloc_optional</i>&lt;U&gt;&amp; v);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>*rhs</tt> as the constructor argument. 
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_same&lt;T,U&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const U&amp;, T&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt> 
<br/><tab/>The expression inside <tt>explicit</tt> is equivalent to:
<br/><tab2/><tt>!is_convertible_v&lt;const U&amp;, T&gt;</tt> 
<br/>     


<br/>
<br/><code>template&lt;class U&gt; explicit(see below) <i>alloc_optional</i>(<i>alloc_optional</i>&lt;U&gt;&amp;&amp; v);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>std​::​move(*rhs)</tt> as the constructor argument. <tt>bool(rhs)</tt> is unchanged.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T,U&amp;&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_same&lt;T,U&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const U&amp;, T&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt> 
<br/><tab/>The expression inside <tt>explicit</tt> is equivalent to:
<br/><tab2/><tt>!is_convertible_v&lt;U, T&gt;</tt> 
<br/>    

<br/>
<br/><code>template&lt;class U&gt; explicit(see below) <i>alloc_optional</i>(const std::optional&lt;U&gt;&amp; v);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>*rhs</tt> as the constructor argument. 
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const U&amp;, T&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt> 
<br/><tab/>The expression inside <tt>explicit</tt> is equivalent to:
<br/><tab2/><tt>!is_convertible_v&lt;const U&amp;, T&gt;</tt> 
<br/>     


<br/>
<br/><code>template&lt;class U&gt; explicit(see below) <i>alloc_optional</i>(std::optional&lt;U&gt;&amp;&amp; v);</code>
<br/><tab/><i>Effects:</i> <tt>M_pmr</tt> is initialized with <tt>std::pmr::get_default_resource()</tt>. 
If <tt>rhs</tt> contains a value, initializes the contained value with uses-allocator construction and 
<tt>std​::​move(*rhs)</tt> as the constructor argument. <tt>bool(rhs)</tt> is unchanged.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i> This constructor shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T,U&amp;&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const U&amp;, T&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, and 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt> 
<br/><tab/>The expression inside <tt>explicit</tt> is equivalent to:
<br/><tab2/><tt>!is_convertible_v&lt;U, T&gt;</tt> 
<br/>  
    <br/>
    
    
<code>        <br/><i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a);
<br/><i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a, const <i>alloc_optional</i>&amp;);
<br/><i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a, <i>alloc_optional</i>&amp;&amp;) noexcept(see below);
<br/>template&lt;class... Args&gt;
  <br/><tab/>explicit <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a, Args&amp;&amp;...);
<br/>template&lt;class U, class... Args&gt;
  <br/><tab/>explicit <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a, initializer_list&lt;U&gt;, Args&amp;&amp;...);
<br/>template&lt;class U = T&gt;
  <br/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a,U&amp;&amp;);
<br/>template&lt;class U&gt;
  <br/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a,const <i>alloc_optional</i>&lt;U&gt;&amp;;
<br/>template&lt;class U&gt;
  <br/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a,<i>alloc_optional</i>&lt;U&gt;&amp;&amp;);
	<br/>template&lt;class U&gt;
  <br/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a,const std::optional&lt;U&gt;&amp;;
<br/>template&lt;class U&gt;
  <br/><tab/>explicit(see below) <i>alloc_optional</i>(allocator_arg_t, const Alloc&amp; a,std::optional&lt;U&gt;&amp;&amp;);  
      </code>
<br/><tab/><i>Requires:</i> <tt>uses_allocator&lt;T,Alloc&gt;</tt> is true;
<br/><tab/><i>Effects:</i> Equivalent to the preceding constructors except that <tt>M_pmr</tt> is initialized with <tt>a.resource()</tt>.
      </blockquote></ins></p>

<p><h3><ins> Destructor [<i>alloc_optional</i>.dtor]</ins></h3></p>
<blockquote><ins>
<br/><tt>~<i>alloc_optional</i>();</tt>
<br/><tab/><i>Effects:</i> If <tt>is_­trivially_­destructible_­v&lt;T&gt; != true</tt> and <tt>*this</tt> contains a value, calls
<tt>val->T::~T()</tt>
<br/><tab/><i>Remarks:</i> If <tt>is_­trivially_­destructible_­v&lt;T&gt;</tt> is <tt>true</tt>, then this destructor is trivial.
</ins></blockquote>

<p><h3><ins> Assignment [<i>alloc_optional</i>.assign]</ins></h3></p>
<blockquote><ins>
<br/><tt><i>alloc_optional</i>&lt;T&gt;&amp; operator=(nullopt_t) noexcept;</tt>
<br/><tab/><i>Effects:</i> If <tt>*this</tt> contains a value, calls <tt>val->T::~T()</tt> to destroy the contained value; otherwise
no effect.
<br/><tab/><i>Remarks:</i> <tt>*this</tt>
<br/><tab/><i>Ensures:</i> <tt>*this</tt> does not contain a value.


<br/>
<br/><tt><i>alloc_optional</i>&lt;T&gt;&amp; operator=(const <i>alloc_optional</i>&amp; rhs);</tt>
<br/><tab/><i>Effects:</i> See Table
<blockquote><table border="1">
<caption><ins>Table &mdash; <tt><i>alloc_optional</i> operator=(const <i>alloc_optional</i>&amp; rhs)</tt> effects</ins></caption>
<tr>
<th></th>
<th><ins><tt>*this</tt> contains a value</ins></th>
<th><ins><tt>*this</tt> does not contain a value</ins></th>
</tr>
<tr>
<td><ins><tt>rhs</tt> contains a value</ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value with uses-allocator construction and 
<tt>*rhs</tt> as the constructor argument.</ins></td>
</tr>
<tr>
<td><ins><tt>rhs</tt> does not contain a value</ins></td>
<td><ins>destroys the contained value by calling <tt>val->T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>
</table></blockquote>
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
This operator shall be defined as deleted unless <tt>is_­copy_­constructible_­v&lt;T&gt; is <tt>true</tt> and 
 <tt>is_­copy_­assignable_­v&lt;T&gt; is <tt>true</tt>. 

<br/>
<br/><tt><i>alloc_optional</i>&lt;T&gt;&amp; operator=(<i>alloc_optional</i>&amp;&amp; rhs);</tt>
<br/><tab/><i>Effects:</i> See Table
<blockquote>
<table border="1">
<caption><ins>Table &mdash; <tt><i>alloc_optional</i> operator=(<i>alloc_optional</i>&amp;&amp; rhs)</tt> effects</ins></caption>
<tr>
<th></th>
<th><ins><tt>*this</tt> contains a value</ins></th>
<th><ins><tt>*this</tt> does not contain a value</ins></th>
</tr>
<tr>
<td><ins><tt>rhs</tt> contains a value</ins></td>
<td><ins>assigns <tt>std​::​move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value with uses-allocator construction and <tt>std​::​move(*rhs)</tt> as the constructor argument.</ins></td>
</tr>
<tr>
<td><ins><tt>rhs</tt> does not contain a value</ins></td>
<td><ins>destroys the contained value by calling <tt>val->T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>
</table></blockquote>
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
This operator shall not participate in overload resolution unless <tt>is_­move_­constructible_­v&lt;T&gt; is <tt>true</tt> and 
 <tt>is_­move_­assignable_­v&lt;T&gt; is <tt>true</tt>. 


<br/>
<br/><code>template&lt;class U = T&gt; <i>alloc_optional</i>&amp; operator=(U&amp;&amp; v);</code>
<br/><tab/><i>Effects:</i> If <tt>*this</tt> contains a value, assigns <tt>std​::​forward&lt;U&gt;(v)</tt> to the contained value;
otherwise initializes the contained value with uses-allocator construction and <tt>std​::​forward&lt;U&gt;(v)</tt> as the constructor argument.
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>*this</tt> contains a value.
<br/><tab/><i>Remarks:</i> This function shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­same_­v&lt;remove_­cvref_­t&lt;U&gt;, alloc_optional&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>conjunction_­v&lt;is_­scalar&lt;T&gt;, is_­same&lt;T, decay_­t&lt;U&gt;&gt;&gt;</tt> is <tt>false</tt>,
<br/><tab2/> - <tt>is_­constructible_­v&lt;T,U&gt;</tt> is <tt>true</tt>, and
<br/><tab2/> - <tt>is_­assignable_­v&lt;T&amp;,U&gt;</tt> is <tt>true</tt> 

<br/>
<br/><tt>template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(const <i>alloc_optional</i>&lt;U&gt;&amp; rhs);</tt>
<br/><tab/><i>Effects:</i> See Table
<blockquote>
<table border="1">
<caption><ins>Table &mdash; <tt><i>alloc_optional</i> operator=(const <i>alloc_optional</i>&lt;U&gt;&amp;)</tt> effects</ins></caption>
<tr>
<th></th>
<th><ins><tt>*this</tt> contains a value</ins></th>
<th><ins><tt>*this</tt> does not contain a value</ins></th>
</tr>
<tr>
<td><ins><tt>rhs</tt> contains a value</ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value with uses-allocator construction and <tt>*rhs</tt> as the constructor argument.</ins></td>
</tr>
<tr>
<td><ins><tt>rhs</tt> does not contain a value</ins></td>
<td><ins>destroys the contained value by calling <tt>val->T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>
</table></blockquote>
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
This operator shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_same&lt;T,U&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_assignable&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>,
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt> 

<br/>
<br/><tt>template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(const std::optional&lt;U&gt;&amp; rhs);</tt>
<br/><tab/><i>Effects:</i> The result of the expression <tt>bool(rhs)</tt> remains unchanged. See Table
<blockquote>
<table border="1">
<caption><ins>Table &mdash; <tt><i>alloc_optional</i> operator=(const std::optional&lt;U&gt;&amp;)</tt> effects</ins></caption>
<tr>
<th></th>
<th><ins><tt>*this</tt> contains a value</ins></th>
<th><ins><tt>*this</tt> does not contain a value</ins></th>
</tr>
<tr>
<td><ins><tt>rhs</tt> contains a value</ins></td>
<td><ins>assigns <tt> std​::​move(*rhs)</tt> to the contained value</ins></td>
<td><ins>initializes the contained value with uses-allocator construction and <tt> std​::​move(*rhs)</tt> as the constructor argument.</ins></td>
</tr>
<tr>
<td><ins><tt>rhs</tt> does not contain a value</ins></td>
<td><ins>destroys the contained value by calling <tt>val->T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>
</table></blockquote>
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
This operator shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, U&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_assignable&lt;T&amp;, U&gt;</tt> is <tt>true</tt>,
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt> 


<br/>
<br/><tt>template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(<i>alloc_optional</i>&lt;U&gt;&amp;&amp; rhs);</tt>
<br/><tab/><i>Effects:</i> See Table
<blockquote>
<table border="1">
<caption><ins>Table &mdash; <tt><i>alloc_optional</i> operator=(<i>alloc_optional</i>&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>
<tr>
<th></th>
<th><ins><tt>*this</tt> contains a value</ins></th>
<th><ins><tt>*this</tt> does not contain a value</ins></th>
</tr>
<tr>
<td><ins><tt>rhs</tt> contains a value</ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value with uses-allocator construction and <tt>*rhs</tt> as the constructor argument.</ins></td>
</tr>
<tr>
<td><ins><tt>rhs</tt> does not contain a value</ins></td>
<td><ins>destroys the contained value by calling <tt>val->T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>
</table></blockquote>
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
This operator shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_same&lt;T,U&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_assignable&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>,
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const U&amp;, T&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>

<br/>
<br/><tt>template&lt;class U&gt; <i>alloc_optional</i>&amp; operator=(std::optional&lt;U&gt;&amp;&amp; rhs);</tt>
<br/><tab/><i>Effects:</i> See Table
<blockquote>
<table border="1">
<caption><ins>Table &mdash; <tt><i>alloc_optional</i> operator=(std::optional&lt;U&gt;&amp;&amp;)</tt> effects</ins></caption>
<tr>
<th></th>
<th><ins><tt>*this</tt> contains a value</ins></th>
<th><ins><tt>*this</tt> does not contain a value</ins></th>
</tr>
<tr>
<td><ins><tt>rhs</tt> contains a value</ins></td>
<td><ins>assigns <tt>*rhs</tt> to the contained value</ins></td>
<td><ins>initializes the contained value with uses-allocator construction and <tt>*rhs</tt> as the constructor argument.</ins></td>
</tr>
<tr>
<td><ins><tt>rhs</tt> does not contain a value</ins></td>
<td><ins>destroys the contained value by calling <tt>val->T::~T()</tt></ins></td>
<td><ins>no effect</ins></td>
</tr>
</table></blockquote>
<br/><tab/><i>Returns:</i> <tt>*this</tt>.
<br/><tab/><i>Ensures:</i> <tt>bool(rhs) == bool(*this)</tt>.
<br/><tab/><i>Remarks:</i> If any exception is thrown, the result of the expression <tt>bool(*this)</tt> remains unchanged.
This operator shall not participate in overload resolution unless
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const U&amp;&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_assignable&lt;T&amp;, const U&amp;&gt;</tt> is <tt>true</tt>,
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­constructible_­v&lt;T, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const U&amp;, T&gt;</tt> is <tt>true</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;<i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_­convertible_­v&lt;const std::optional&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>,
<br/><tab2/> - <tt>is_­convertible_­v&lt;const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;, T&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&gt;</tt> is <tt>false</tt>, 
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const std::optional&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>, and
<br/><tab2/> - <tt>is_assignable_v&lt;T&amp;, const <i>alloc_optional</i>&lt;U&gt;&amp;&amp;&gt;</tt> is <tt>false</tt>


<br/>
<br/><code>  template&lt;class... Args&gt;> T&amp; emplace(Args&amp;&amp;...);</code>
<br/><tab/><i>Requires:</i> <tt>is_­constructible_­v&lt;T, Args&amp;&amp;...&gt; </tt>is true.
<br/><tab/><i>Effects:</i> Calls <tt>*this = nullopt</tt>. Then initializes the contained value 
with uses-allocator construction and <tt>std​::​forward&lt;Args&gt;(args)....</tt> as the constructor argument.
<br/><tab/><i>Ensures:</i> <tt>*this</tt> contains a value.
<br/><tab/><i>Returns:</i> A reference to the new contained value.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i>  If an exception is thrown during the call to <tt>T</tt>'s constructor, 
<tt>*this</tt> does not contain a value, and the previous <tt>*val</tt> (if any) has been destroyed. 


<br/>
<br/><code>    template&lt;class U, class... Args&gt; T&amp; emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);</code>
<br/><tab/><i>Requires:</i> <tt>is_­constructible_­v&lt;T, initializer_­list&lt;U&gt;&amp;, Args&amp;&amp;...&gt; </tt>is true.
<br/><tab/><i>Effects:</i> Calls <tt>*this = nullopt</tt>. Then initializes the contained value 
with uses-allocator construction and <tt>il, std​::​forward&lt;Args&gt;(args)....</tt> as the constructor arguments.
<br/><tab/><i>Ensures:</i> <tt>*this</tt> contains a value.
<br/><tab/><i>Returns:</i> A reference to the new contained value.
<br/><tab/><i>Throws:</i> Any exception thrown by the selected constructor of <tt>T</tt>.
<br/><tab/><i>Remarks:</i>  If an exception is thrown during the call to <tt>T</tt>'s constructor, 
<tt>*this</tt> does not contain a value, and the previous <tt>*val</tt> (if any) has been destroyed. 

</ins></blockquote>
</body>
</html> 