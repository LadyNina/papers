<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>A Customization Point for domain-specific allocators</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	</style>
</head>
<body>

<address align=right>
Document number: dxxxx
<br/>
Audience: LEWG
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
<a href="mailto:dinka.ranns@gmail.com">Nina Dinka Ranns</a><br/>
2019-08-02<br/>
</address>
<hr/>
<h1 align=center>A Customization Point for domain-specific allocators</h1>

<h2>Abstract</h2>

<p>
  This is a proposal for a new customization point for allocators; namely,
  it's a mechanism for adapting legacy allocators into uses-allocator
  construction, and allows external trait-adaptation of legacy allocators into
  the standard allocator model. Such adaptation allows even legacy
  allocators that are raw pointers to be used with uses-allocator construction;
  in such cases, there is no converting constructor on the target
  legacy allocator type that could be used, because legacy types traffick
  in allocator pointers. The customization point provides a mechanism
  for converting a standard allocator into the right kind of target
  type, including raw pointers.
</p>
<p>
  Such a mechanism is thus a significant migration help for
  existing code that uses legacy 3rd party allocators, for migrating
  such code to use standard allocators and standard-allocator-aware
  types. We can use e.g. pmr::vector with such legacy types and legacy
  allocators with minimal modifications.
</p>

<h2>tl;dr</h2>

<p>
  First, we define a primary template for the customization point:
</p>

<pre><blockquote><code>template &lt;class _Tp, class _Alloc&gt;
 struct __domain_allocator_traits {
    static constexpr bool value = false;
  };
</code></blockquote></pre>

<p>__domain_allocator_traits&lt;class T, class Alloc&gt;::value specifies whether type T supports uses allocator construction with a 
domain specific allocator DomainAlloc which can be mapped to an object of Alloc type. A specialization is required to provide an Alloc to DomainAlloc 
rebind function.  </p>
<p>A specialization looks roughly like the following:
</p>

<pre><blockquote><code>namespace std {
template&lt;&gt;
struct __domain_allocator_traits&lt;my_value_type, std::pmr::polymorphic_allocator&lt;&gt;&gt; {
    static constexpr bool value = false;
    static my_alloc* rebind(std::pmr::polymorphic_allocator&lt;&gt; _a);
};
</code></blockquote></pre>


<p>And a real-life specialization looks like the following:
</p>

<pre><blockquote><code>namespace std {
  template &lt;class TYPE&gt;
    struct __domain_allocator_traits&lt;TYPE, typename bsl::enable_if&lt;
      BloombergLP::bslma::UsesBslmaAllocator&lt;TYPE&gt;::value,
    std::pmr::polymorphic_allocator&lt;&gt;&gt;::type>
: BloombergLP::bslma::UsesBslmaAllocator&lt;TYPE&gt;::type
{
  static BloombergLP::bslma::Allocator* rebind(std::pmr::polymorphic_allocator&lt;&gt;const& a)
    {
      return dynamic_cast&lt;BloombergLP::bslma::Allocator*&gt;(a.resource());
    }
}</code></blockquote></pre>

<p>We also thought it would be a good idea to allow an in-class opt-in by providing a static member function
<tt>domain_alloc_rebind</tt> which is invokable with <tt>_Alloc const&</tt>, where <tt>_Alloc</tt> is the second template
parameter to __domain_allocator_traits. 

An implementation of a such a detection mechanism would look something like this :
<pre><blockquote><code>namespace std {
	 template &lt;class _Tp, class _Alloc, typename =  __void_t&lt;&gt;&gt;
	struct __domain_allocator_detector
	: false_type
	{
	};
	
	template &lt;class _Tp, class _Alloc&gt;
	struct __domain_allocator_detector&lt; _Tp, _Alloc,
	__void_t&lt;decltype(_Tp::domain_alloc_rebind)&gt;&gt;
	: __is_invocable&lt;decltype(_Tp::domain_alloc_rebind), const _Alloc&&gt;::type
	{
		using __rT = decltype(_Tp::domain_alloc_rebind);
		inline static __rT* rebind = &_Tp::domain_alloc_rebind;
	};

	 template &lt;class _Tp, class _Alloc&gt;
	 struct __domain_allocator_traits
	 : __domain_allocator_detector&lt;_Tp, _Alloc&gt; {
	
	 };
}</code></blockquote></pre>

</p>

<p>
  Finally, we modify uses-allocator construction so that
  it detects the presence of <tt>__domain_allocator_traits&lt;T, Alloc&gt;::rebind</tt>
  , calls it if it's present, and uses the result as an allocator. We assume trailing-allocator convention for a
  type with a domain allocator. This can be elaborated to detect leading-allocator convention vs trailing-allocator convention much like
  types which satisfy the current implementation of <tt>uses_allocator</tt>. 
</p>								   

<h2>An alternative way</h2>

<p>
  In early stages of prototyping of this proposal, we used
  a simpler downcast operator added to polymorphic_allocator.
  It looks like this:
</p>

<pre><blockquote><code>template &lt;typename _Target,
  typename =
  enable_if_t&lt;
    __is_dynamic_castable&lt;_Target*, memory_resource*&gt;::value
     &amp;&amp; !is_same_v&lt;_Target, memory_resource&gt;&gt;&gt;
  operator _Target*() const
    {
      memory_resource* res = resource();
      _Target&amp; ret = dynamic_cast&lt;_Target&apm;&gt;(*res);
      return &amp;ret;
    }
</code></blockquote></pre>

<p>
  This was deemed too fishy (because it's an implicit downcasting
  conversion) by some early reviewers. It is, however,
  a much simpler solution than a new customization point. In this
  alternative approach, uses-allocator construction is not modified,
  and all that is needed for legacy types is uses_allocator specializations,
  and with the nifty trick we showed above for __domain_allocator_traits,
  there needs to be only one (in that case for plain uses_allocator),
  even though there's dozens of legacy types that need adaptation.
  There is also no need for a new customization point in this alternative
  approach.
</p>

<h2>Impact on current usage of uses_allocator</h2>
<p>
  To keep the behaviour consistent with uses_allocator_construct, uses_allocator_construction_args,
  scoped_allocator_adaptor::construct,polymorphic_allocator::construct and tuple need to change
  to accomodate for a domain specific allocator. 
</p>
<h2>Should we modify uses_allocator ? </h2>
<p>
  We have implemented two approaches:
  <ul>
    <li>one where uses_allocator is unmodified and does not check __domain_allocator_traits </li>
    <li>another where uses_allocator depends on __domain_allocator_traits</li>
  </ul>
</p>
<p>
  Orginally we keept uses_allocator separate from __domain_allocator_traits in order to 
  limit the impact of this extension; not modyifying uses_allocator means the set of types 
  for which <tt>uses_allocator</tt> is true remains the same. There already exists a set of types for which 
  uses_allocator is false, but for which uses allocator constuction is well defined.</p>

<p>
  Where this matters is that a type that makes some sort of a decision
  based on whether a template parameter supports allocators may need
  to use two traits instead of one to make that decision. Our separately
  proposed pmr::optional is such a type. With the first approach,
  it needs to use both uses_allocator and __domain_allocator_traits
  to decide whether to enable allocator support for the parametered
  type. In the second approach, it needs only uses_allocator. Types
  like pmr::vector don't care, but types that change their internal
  storage and API based on this decision do care.
</p>  
  
  
</p>  On further consideration, we concluded that, if a type can convert from a selected allocator
  to a domain specific allocator, and does so by either specialising the __domain_allocator_traits trait 
  or providing the domain_alloc_rebind function, then the intentions is to have this type behave as if it 
  "uses_allocator" and therefore the definition of <tt>uses_allocator</tt> should take such a conversion into account. 
  This allows such a type to get all the benefits of being uses_alloctor, not just the uses_alloctor construction.

</p>

<p>
  LEWG should decide whether uses_allocator should depend on
  __domain_allocator_traits. 
</p>

<h2>Proposed wording</h2>


<p>
Insert new section after [allocator.uses.trait]:
</p>

 <h3>Class template domain_allocator_traits</h3>
<code>namespace std {
         template &lt;class T, class Alloc&gt; struct domain_allocator_traits {};
         }
         </code>
</p></blockquote>
<p><tt>domain_allocator_traits</tt> provides a means to get uses-allocator construction with allocator types other than the
type specific allocator. Meets the <i>Cpp17BinaryTypeTrait</i> requirements ([meta.rqmts]). </p>

<p>If <tt>domain_allocator_traits&lt;class T, class Alloc&gt;::value</tt> is <tt>true</tt>,  there will exist a 
function object member of <tt>domain_allocator_traits</tt> called <tt>rebind</tt> which when invoked with a parameter of type Alloc
will return type DomainAlloc, and type T will have trailing_allocator convention constructors using DomainAlloc. 
Otherwise, <tt>domain_allocator_traits&lt;class T, class Alloc&gt;::value</tt> will be <tt>false</tt>. </p>

<p>Implementation shall provide a definition of <tt>domain_allocator_traits&lt;class T, class Alloc&gt</tt> that is 
derived from <tt>true_­type</tt> if there exists a function object member <tt>T::domain_alloc_rebind</tt> for 
which <tt>is_invocable&lt;decltype(T::domain_alloc_rebind), const _Alloc&&gt;::value</tt> is <tt>true</tt>. </p> 



<p><br/>Modify 20.10.8.1 uses_­allocator trait [allocator.uses.trait]</p>

<p><tt>template &lt;class T, class Alloc&gt; struct uses_allocator;</tt>
<br/>
<i>#Remarks:</i> Automatically detects whether <tt>T</tt> has a nested allocator_­type that is convertible from <tt>Alloc</tt>. 
Meets the <i>Cpp17BinaryTypeTrait</i> requirements ([meta.rqmts]). The implementation shall provide a definition that is 
derived from <tt>true_­type</tt> if<ins>
<br/> - </ins>the <i>qualified-id</i> <tt>T::allocator_­type</tt> is valid and denotes a type ([temp.deduct]) and 
<tt>is_­convertible_­v&lt;Alloc, T::allocator_­type&gt; != false</tt>,<ins> or
<br/> - if <tt>__domain_allocator_traits&lt;T, Alloc&gt;::value</tt> is <tt>true</tt></ins> 
<br/><br/>
<del>otherwise it</del><ins>It</ins> shall be derived from <tt>false_­type</tt><ins> otherwise</ins>. 
A program may specialize this template to derive from <tt>true_­type</tt> for a program-defined type <tt>T</tt> that does not
have a nested <tt>allocator_­type</tt> but nonetheless can be constructed with an allocator where either:
<br/>- the first argument of a constructor has type allocator_­arg_­t and the second argument has type <tt>Alloc</tt> or
<br/>- the last argument of a constructor has type <tt>Alloc</tt>.

</p>


<p>
Modify [allocator.uses.construction]/p1
<blockquote>
 <p>
<i>Uses-allocator construction</i> with allocator <tt>Alloc</tt> and constructor arguments <tt>args...</tt> refers to the construction
of an object of type <tt>T</tt> such that <tt>Alloc</tt> is passed to the constructor of T if T uses an allocator type compatible
with <tt>Alloc</tt><ins>  or <tt>__domain_allocator_traits&lt;T, Alloc&gt;::value</tt> is <tt>true</tt></ins>.
</p></blockquote>
</p>

<p>
Modify [allocator.uses.construction]/p2
<blockquote>
The following utility functions support <del>three</del><ins>four</ins> conventions for passing <tt>alloc</tt> to a constructor:
 ...<br/>
 <p>
<ins>- Otherwise, if <tt>__domain_allocator_traits&lt;T, Alloc&gt;::value</tt> is <tt>true</tt>,
uses-allocator construction invokes T(args..., __domain_allocator_traits&lt;T, Alloc&gt;::rebind(alloc))</ins>
</p></blockquote>
</p>

<p>
Modify [allocator.uses.construction]/p5
<blockquote>
 <p>
 <i>Returns:</i> A tuple value determined as follows:<br/>
 ...<br/>
<ins> - Otherwise, if <tt>__domain_allocator_traits&lt;T, Alloc&gt;::value</tt> is <tt>true</tt>, return <tt>forward_as_tuple(std::forward&lt;Args&gt;(args)..., 
__domain_allocator_traits&lt;T, Alloc&gt;::rebind(alloc))</tt>.</ins>.
</p></blockquote>
</p>

</body>
</html>
