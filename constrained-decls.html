<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<title>Yet another approach for constrained declarations</title>

	<style type="text/css">
        html {font-family: "DejaVu Serif", serif; size: medium; line-height: 150%; margin: 0; padding: 0;}
        code {font-family: "DejaVu Sans Mono", monospace; size: medium; line-height: 135%;}
        body {margin: 1em 2em; padding: 0;}
        h2, h3, h4 {margin: 1.5em 0 1em 0;}
	p, li {text-align:justify}
	ol.wide li {margin-top:1em;}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
        blockquote.std
        {
                max-width: 55em;
                border-left: thick solid #AAA;
                padding-left: 1em;
        }
        blockquote.stdins
        {
                max-width: 55em;
                border-left: thick solid #00A000;
                padding-left: 1em;
        }
        blockquote.stdins * { color: #00A000; /* text-decoration: underline; */ }
	ins {color:#00A000}
	del {color:#A00000}
        p > code, li > code {color: #000080;}

	table { border: 1px solid black; border-spacing: 0px;
	  margin-left: auto; margin-right: auto; }
	th { text-align: left; vertical-align: top;
	  padding-left: 0.8em; border: none; }
	td { text-align: left; vertical-align: top;
	  padding-left: 0.8em; border: none; }

	table.table { border-spacing: 2px; border-collapse: separate; }
	.table * th, .table * td { border: 1px solid black; }

        /* ul[del] is a list with deleted bullets */
        ul.del li {
          list-style-type: none;
          list-style-position: outside;
          text-indent: -1ex;
        }
        ul.del li:before {
          display: inline-block;
          content: "\2022";
          color: #A00000;
          text-decoration: line-through;
          width: 1ex;
        }
	</style>
</head>
<body>

<address style="text-align:right;">
Document number: D1141R2
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
<a href="mailto:tkoeppe@google.com">Thomas K&ouml;ppe</a><br/>
<a href="mailto:andrew.n.sutton@gmail.com">Andrew Sutton</a><br/>
<a href="mailto:hsutter@microsoft.com">Herb Sutter</a><br/>
<a href="mailto:gdr@microsoft.com">Gabriel Dos Reis</a><br/>
<a href="mailto:bjarne@stroustrup.com">Bjarne Stroustrup</a><br/>
<a href="mailto:jason@redhat.com">Jason Merrill</a><br/>
<a href="mailto:hubert.reinterpretcast@gmail.com">Hubert Tong</a><br/>
<a href="mailto:eric.niebler@gmail.com">Eric Niebler</a><br/>
<a href="mailto:casey@carter.net">Casey Carter</a><br/>
<a href="mailto:tom@honermann.net">Tom Honermann</a><br/>
<a href="mailto:erich.keane@intel.com">Erich Keane</a><br/>
<a href="mailto:webrown.cpp@gmail.com">Walter E. Brown</a><br/>
<a href="mailto:mike_spertus@symantec.com">Michael Spertus</a><br/>
2018-11-05<br/>
</address>

<hr>

<h1 style="text-align: center;">Yet another approach for constrained declarations</h1>

<h2>Abstract</h2>

<p>
  We propose a short syntax for the constrained declaration
  of function parameters, function return types and
  variables. The new syntax is a &ldquo;constrained
  <code>auto</code>&rdquo;, e.g. <code>void sort(Sortable auto&amp; c);</code>.
</p>

<h2>Contents</h2>
<ol>
  <li><a href="#revisions">Revision history</a></li>
  <li><a href="#summary">Proposal summary</a></li>
  <li><a href="#proposal">Proposal details</a>
      <ul>
        <li><a href="#part1">Part 1: &ldquo;Constrained <code>auto</code>&rdquo;</a></li>
        <li><a href="#part2">Part 2: Relaxed &ldquo;constrained <code>auto</code>&rdquo;</a> [not proposed]</li>
        <li><a href="#part3">Part 3: Meaning of &ldquo;<code>template &lt;Concept T&gt;</code>&rdquo;</a></li>
        <li><a href="#part4">Part 4: Meaning of &ldquo;<code>template &lt;Concept... T&gt;</code>&rdquo; and its friends</a></li>
        <li><a href="#part5">Part 5: Meaning of &ldquo;<code>-&gt; Concept auto</code>&rdquo; and its friends</a> [not proposed]</li>
      </ul>
  </li>
  <li><a href="#wording">Proposed wording for Parts 1, 3, and 4</a>
      <ul>
        <li><a href="#wordingpt1">For Part 1</a></li>
        <li><a href="#wordingpt3">For Part 3</a></li>
        <li><a href="#wordingpt4">For Part 4</a></li>
      </ul>
  </li>
</ol>

<h2 id="revisions">Revision history</h2>
<ul>
  <li>This document:
    Added formal wording for parts 1, 3, and 4. Parts 2 and 5 are not being proposed.</li>
  <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r1.html">P1141R1</a>:
    Added discussion in Parts 2 and 5 on <i>return-type-requirement</i>s and in Part 4 on variadic concepts.
  </li>
  <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r0.html">P1141R0</a>:
    Initial proposal.</li>
</ul>

<h2 id="summary">Proposal summary</h2>

<p>This paper proposes three things:</p>
<ol class="wide">
  <li>A syntax for constrained declarations that is practically a
    &ldquo;constrained <code>auto</code>&rdquo;;
    the principle being &ldquo;wherever <code>auto</code> goes,
    a <code>Constraint auto</code> can also (non-recursively) go&rdquo;.
    The semantics are to deduce like <code>auto</code> and additionally check a constraint.
    In a nutshell,
    <blockquote><pre><code>void f(Sortable auto x);
Sortable auto f();      // #1
Sortable auto x = f();  // #2
template &lt;Sortable auto N&gt; void f();</code></pre></blockquote>
    and all combined:
    <blockquote><pre><code>template &lt;Sortable auto N&gt; Sortable auto f(Sortable auto x)
{
    Sortable auto y = init;
}</code></pre></blockquote>
    An unconstrained version of that is:
<blockquote><pre><code>template &lt;auto N&gt; auto f(auto x)
{
    auto y = init;
}</code></pre></blockquote>
    So, this proposal includes <code>auto</code>-typed parameters for
    functions, which we already allow for lambdas.</li>

  <li>Simplifying (and thus restricting) the rules in
    <a href="https://wg21.link/temp.param#10">[temp.param]/10</a>,
    so that <code>template &lt;Sortable S&gt;</code> always
    means that <code>S</code> is a type parameter, and
    <code>template &lt;Sortable auto S&gt;</code> always means
    that <code>S</code> is a non-type parameter. Template template-parameters
    are no longer supported in this short form. Moreover, <code>Sortable</code>
    is restricted to be a concept that takes a type parameter or type parameter pack;
    non-type and template concepts are no longer supported in this short form.
  </li>

  <li>Changing the meaning of parameter packs, so that <code>template &lt;Sortable ...T&gt;</code>
    means <code>requires Sortable&lt;T&gt; &amp;&amp; ... &amp;&amp; true</code>, and not
    <code>requires Sortable&lt;T...&gt;</code>.</li>
</ol>

<p><code>Sortable</code> is a &ldquo;type concept&rdquo; in all the examples of this summary.</p>

<p>
  This paper specifically does <em>not</em> propose
</p>
<ul>
  <li>any new lead-in syntax for templates, or</li>
  <li>a new syntax for introducing names for placeholder types, or</li>
  <li>a shortcut syntax for applying multiple constraints
    to a placeholder type.</li>
</ul>

<p>
  The idea of this approach is to provide a syntax that
</p>
<ul>
  <li>
    works for constrained function parameters, constrained
    return types, constrained variables, and type-constrained
    non-type template parameters;
  </li>
  <li>
    avoids inventing many adventurous new things;
  </li>
  <li>
    in particular, avoids inventing new type sigils;
  </li>
  <li>
    does not clash with explicit template instantiations; and
  </li>
  <li>
    is compatible with what we already have in polymorphic
    lambdas, and makes functions uniform with them.
  </li>
</ul>

<p>The previous revision of this paper
  (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r1.html">P1141R1</a>)
  also proposed (in Part 2) an optional relaxation where the <code>auto</code>
  would be optional for the cases #1 and #2 illustrated above, and (in Part 5) a
  change of the meaning of <code>-&gt; Concept auto</code>. However, EWG decided
  to propose only parts 1, 3, and 4.</p>

<h2 id="proposal">Proposal details</h2>

<h3 id="part1">Part 1: &ldquo;Constrained <code>auto</code>&rdquo;</h3>

<p>
  The approach proposed here borrows a subset of
  <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0807r0.html">P0807R0 An Adjective Syntax for Concepts</a>. The idea is that
  we don&rsquo;t try to come up with a notation that does everything
  that P0807 does; in particular, there is no proposal for a new syntax
  to introduce a type name.
</p>

<h4>Function templates</h4>

<p>
  The approach is simple: allow <code>auto</code> parameters to produce
  function templates (as they produce polymorphic lambdas), and allow the <code>auto</code>
  to be preceded by a concept name. In every case, such a parameter
  is a deduced parameter, and we can see which parameters are deduced
  and which ones are not:
</p>
<blockquote><pre><code>[](auto a, auto&amp; b, const auto&amp; c, auto&amp;&amp; d) {...}; // unconstrained
[](Constraint auto a, Constraint auto&amp; b, const Constraint auto&amp; c, Constraint auto&amp;&amp; d) {...}; // constrained

void f1(auto a, auto&amp; b, const auto&amp; c, auto&amp;&amp; d) {...}; // unconstrained
void f2(Constraint auto a, Constraint auto&amp; b, const Constraint auto&amp; c, Constraint auto&amp;&amp; d) {...}; // constrained

[](Constraint auto&amp;&amp; a, SomethingElse&amp;&amp; b) {...}; // a constrained deduced forwarding reference and a concrete rvalue reference
void f3(Constraint auto&amp;&amp; a, SomethingElse&amp;&amp; b) {...}; // a constrained deduced forwarding reference and a concrete rvalue reference</code></pre></blockquote>
<p>
  The appearance of <code>auto</code> (including <code>Constraint auto</code>)
  in a parameter list
  tells us that we are dealing with a function template. For each parameter,
  we know whether it is deduced or not. We can tell apart
  concepts from types: concepts precede <code>auto</code>, types do not.
</p>

<h4>Return types and variable declarations</h4>

<p>
  Constrained return types work the same way:
</p>
<blockquote><pre><code>auto f4();                  // unconstrained, deduced.

Constraint auto f5();       // constrained, deduced.

Whatever f6();              // See part 2. If Whatever is a type, not deduced.
                            // If Whatever is a concept, constrained and deduced.</code></pre></blockquote>
<p>
  Note that <code>f4</code>, <code>f5</code> and <code>f6</code>
  are not templates (whereas the previous <code>f1</code>, <code>f2</code>
  and <code>f3</code> <em>are</em> templates). Here, there is no
  mention of <code>auto</code> in the parameter list. Users have the choice
  of adopting a style where it is explicit as to whether the return type is deduced.
</p>

<p>
  Constrained types for variables work the same way:
</p>
<blockquote><pre><code>auto x1 = f1();             // unconstrained, deduced.

Constraint auto x2 = f2();  // constrained, deduced.

Whatever x3 = f3();         // See part 2. If Whatever is a type, not deduced.
                            // If Whatever is a concept, constrained and deduced.</code></pre></blockquote>
<p>
  Again, users can make it so that it is easy to see when deduction occurs.
</p>

<p>
  Since non-type template parameters can be deduced via <code>auto</code>
  (as in <code>template &lt;auto N&gt; void f();</code>),
  we also allow a constraint there:
</p>
<blockquote><pre><code>template &lt;Constraint auto N&gt; void f7();</code></pre></blockquote>
<p>
  Note, however, that this can only be a type constraint; non-type concepts
  (including auto concepts) are not allowed in this form.
</p>

<h4>Other uses of <code>auto</code></h4>

<p>
  In concert with the general approach that &ldquo;<code>Constraint auto</code> goes wherever
  <code>auto</code> goes&rdquo;, new-expressions and conversion operators work:
</p>
<blockquote><pre><code>auto alloc_next() { return new Sortable auto(this-&gt;next_val()); }

operator Sortable auto() { }</code></pre></blockquote>

<p>
  A &ldquo;<code>Constraint auto</code>&rdquo; cannot be used to indicate that a function declarator has a trailing return type:
</p>
<blockquote><pre><code>Constraint auto f() -&gt; auto; // ill-formed; shall be the single <i>type-specifier</i> <code>auto</code></code></pre></blockquote>

<p>
  <code>decltype(auto)</code> can also be constrained:
</p>
<blockquote><pre><code>auto f() -&gt; Constraint decltype(auto);
Constraint decltype(auto) x = f();</code></pre></blockquote>

<p>
  Structured bindings do deduce <code>auto</code> in some cases; however, the <code>auto</code> is deduced from the whole (and not from the individual components).
  It is somewhat doubtful that applying the constraint to the whole, as opposed to (for example) applying separately to each component, is the correct semantic.
  Therefore, we propose to defer enabling the application of constraints to structured bindings to separate papers.
</p>

<h4>General rules</h4>

<p>
  The constraint applies directly to the deduced type. It does not apply to the possibly cv-qualified
  type described by the type specifiers, nor does it apply to the type declared for the variable:
</p>
<blockquote><pre><code>const Assignable&lt;int&gt; auto&amp;&amp; c = *static_cast&lt;int *&gt;(p); // Assignable&lt;int &amp;, int&gt;</code></pre></blockquote>
<p>
  Naturally, if the deduced type is cv-qualified (or a reference), the constraint applies
  to that type.
</p>
<p>
  To keep things simple, an <code>auto</code> (or <code>decltype(auto)</code>) being constrained is always immediately preceded by the constraint. So, cv-qualifiers and concept-identifiers
  cannot be freely mixed:
</p>
<blockquote><pre><code>const Contraint auto x = foo(); // ok
Constraint const auto x = foo(); // ill-formed
Constraint auto const y = foo(); // ok</code></pre></blockquote>
<p>
  We propose only the ability to apply one single constraint for a parameter,
  return type, or non-type template parameter. Any proposal to consider multiple
  constraints should happen separately after C++20.
</p>

<p>
  Partial concept identifiers also work. Given a concept
  <code>template &lt;typename T, typename... Args&gt; concept
    Constructible = /* ... */;</code>, we can say:
</p>
<blockquote><pre><code>void f(Constructible&lt;int&gt; auto x);   // Constructible&lt;decltype(x), int&gt; is satisfied

Constructible&lt;int&gt; auto f();

Constructible&lt;int&gt; auto x = f();

template &lt;Constructible&lt;int&gt; auto N&gt; void f();</code></pre></blockquote>

<h3 id="part2" style="color: #666"><span style="text-decoration: line-through">Part 2: Relaxed &ldquo;constrained <code>auto</code>&rdquo;</span> [not proposed]</h3>

<h3 id="part3">Part 3: Meaning of &ldquo;<code>template &lt;Concept T&gt;</code>&rdquo;</h3>

<p>
  In <a href="https://wg21.link/temp.param#10">[temp.param]/10</a> we have:
</p>
<blockquote class="std">
<p>
  A <i>constrained-parameter</i> declares a template parameter whose kind (type, non-type, template) and type
  match that of the prototype parameter (17.6.8) of the concept designated by the <i>qualified-concept-name</i>
  in the <i>constrained-parameter</i>. Let <code>X</code> be the prototype parameter of the designated concept.
  The declared template parameter is determined by the kind of <code>X</code> (type, non-type, template)
  and the optional ellipsis in the <i>constrained-parameter</i> as follows.
</p>
<ul>
  <li>If <code>X</code> is a type <i>template-parameter</i>,
    the declared parameter is a type <i>template-parameter</i>.</li>
  <li>If <code>X</code> is a non-type <i>template-parameter</i>,
    the declared parameter is a non-type <i>template-parameter</i>
    having the same type as <code>X</code>.</li>
  <li>If <code>X</code> is a template <i>template-parameter</i>,
    the declared parameter is a template <i>template-parameter</i>
    having the same <i>template-parameter-list</i> as <code>X</code>,
    excluding default template arguments.</li>
  <li>If the <i>qualified-concept-name</i> is followed by an ellipsis,
    then the declared parameter is a template parameter pack (17.6.3).</li>
</ul>
<p>
  [<i>Example</i>:
</p>
<blockquote><pre><code>template&lt;typename T&gt; concept C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept C2 = true;
template&lt;int N&gt; concept C3 = true;
template&lt;typename... Ts&gt; concept C4 = true;
template&lt;char... Cs&gt; concept C5 = true;

template&lt;C1 T&gt; void f1();       // OK, T is a type template-parameter
template&lt;C2 X&gt; void f2();       // OK, X is a template with one type-parameter
template&lt;C3 N&gt; void f3();       // OK, N has type int
template&lt;C4... Ts&gt; void f4();   // OK, Ts is a template parameter pack of types
template&lt;C4 T&gt; void f5();       // OK, T is a type template-parameter
template&lt;C5... Cs&gt; void f6();   // OK, Cs is a template parameter pack of chars</code></pre></blockquote>
<p>
  &mdash;<i>end example</i>]
</p>
</blockquote>

<p>
  Does that seem like a mouthful?
</p>
<p>
  That&rsquo;s because it is. In <code>template &lt;Constraint T&gt;</code>, the kind of
  <code>T</code> depends on the kind of the prototype parameter of <code>Constraint</code>.
</p>
<p>
  We instead propose that, for such a constrained-parameter syntax:
</p>
<ul>
  <li><code>T</code> should always be a type, and</li>
  <li><code>Constraint</code> would always need to be a concept
  that has a corresponding type parameter or type parameter pack.</li>
</ul>
<p>
  To be clear, we are not proposing that concepts in general should not
  have non-type or template template parameters. We are merely proposing for it to be the case
  that the constrained parameter shortcut is not provided for concepts with
  such prototype parameters; such concepts would need to be used with a <i>requires-clause</i>.
  The constrained parameter syntax should mean just one thing.
  Note that the same syntax <code>template &lt;A T&gt;</code> is still a non-type
  parameter when <code>A</code> is a type name rather than a concept. We are willing
  to tolerate this small potential for ambiguity.</p>
<p>
  The rationale for this part is as follows:
</p>
<ol>
  <li>It seems desirable to have the constrained template parameter syntax.</li>
  <li>It would be nice if that syntax covered the most common case.</li>
  <li>It would further be nice if that syntax covered <em>only</em> the most common case.</li>
  <li>The other cases are expected to be so rare that there&rsquo;s no
    need to provide a shortcut for them, and they are certainly rare enough
    that they shouldn&rsquo;t use the same syntax.</li>
</ol>
<p>
  So, to clarify:
</p>
<ul>
  <li><code>template &lt;MyIntTypeDef N&gt;</code> means
    a non-type parameter, like it always did.</li>
  <li><code>template &lt;ConceptName T&gt;</code> means
    a type parameter constrained by <code>ConceptName</code>,
    and the prototype parameter of <code>ConceptName</code> needs to be
    a type parameter or a type parameter pack.</li>
  <li><code>template &lt;auto N&gt;</code> means a non-type parameter
    with a deduced type.</li>
  <li><code>template &lt;ConceptName auto N&gt;</code> means
    a non-type parameter with a deduced type constrained by
    <code>ConceptName</code>, and the prototype parameter of <code>ConceptName</code>
    needs to be a type parameter or a type parameter pack.</li>
</ul>
<p>
  Other use cases can be done with <i>requires-clause</i>s.
</p>

<h3 id="part4">Part 4: Meaning of &ldquo;<code>template &lt;Concept... T&gt;</code>&rdquo; and its friends</h3>

<p>
  In <a href="https://wg21.link/temp.param#11">[temp.param]/11</a> we have:
</p>
<blockquote class="std"><pre><code>template&lt;C2... T&gt; struct s3; // associates C2&lt;T...&gt;
</code></pre></blockquote>
<p>
  This seems to be doing an unexpected thing, which is having the constraint
  apply to more than one type in a pack at a time. We propose that, regardless of whether the prototype parameter of the named concept is a pack:
</p>
<ul>
  <li>For a simple pack of constrained types, the concept
    mentioned is applied, as a unary concept, to each type in the pack in turn.</li>
  <li>For a pack of constrained types that use <i>partial-concept-id</i>s,
    the concept
    mentioned is applied, as an n-ary concept whose arity is unaffected by the size of the pack, <i>individually</i> to each type in the pack in turn.</li>
</ul>
<p>
  In other words,
</p>
<ul>
  <li><code>template &lt;ConceptName... T&gt; void f(T...);</code>
    means a variadic function template where each type in the pack
    <code>T</code> needs to satisfy <code>ConceptName</code> as a unary concept, applied
    as <code>ConceptName&lt;T<sub>n</sub>&gt;</code>.</li>
  <li>Similarly, <code>void f(ConceptName auto... T);</code>
    means exactly the same thing.</li>
  <li><code>template &lt;ConceptName&lt;int&gt;... U&gt; void f(U...);</code>
    means a variadic function template where each type in the pack
    <code>U</code> needs to satisfy <code>ConceptName</code> as a binary concept, applied
    as <code>ConceptName&lt;U<sub>n</sub>, int&gt;</code>.</li>
  <li>Similarly, <code>void f(ConceptName&lt;int&gt; auto... U);</code>
    means exactly the same thing.</li>
  <li><code>template &lt;ConceptName&lt;0u, void, wchar_t&gt;... U&gt; void f(U...);</code>
    means a variadic function template where each type in the pack
    <code>U</code> needs to satisfy <code>ConceptName</code> as a n-ary concept, applied
    as <code>ConceptName&lt;U<sub>n</sub>, 0u, void, wchar_t&gt;</code>.</li>
</ul>

<h3 id="part5" style="color: #666"><span style="text-decoration: line-through">Part 5: Meaning
    of &ldquo;<code>-&gt; Concept auto</code>&rdquo; and its friends</span> [not proposed]</h3>

<h2 id="wording">Proposed wording for Parts 1, 3, and 4</h2>

<h3 id="wordingpt1">For Part 1</h3>

<p>
  Update [expr.prim.lambda, 7.5.5], paragraph 5, to allow
  <i>constrained-type-specifier</i>s as lambda parameters.
</p>

<blockquote class="std">
  <p>A lambda is a generic lambda if the <code>auto</code>
  <ins>or <i>qualified-concept-name</i> <code>auto</code> </ins><i>type-specifier</i>
  appears as one of the <i>decl-specifier</i>s in the <i>decl-specifier-seq</i>
  of a <i>parameter-declaration</i> of the <i>lambda-expression</i>,
  or if the lambda has a template-parameter-list.</p>
</blockquote>

<p>
  In [expr.prim.lambda.closure, 7.5.5.1], modify paragraph 3.
</p>

<blockquote class="std">
  <p>The closure type for a non-generic lambda-expression has a public inline
  function call operator (11.5.4) whose parameters and return type are described
  by the <i>lambda-expression</i>&rsquo;s <i>parameter-declaration-clause</i>
  and <i>trailing-return-type</i> respectively.
  For a generic lambda, the closure type has a public inline function call
  operator member template (12.6.2) whose <i>template-parameter-list</i>
  consists of the specified <i>template-parameter-list</i>, if any, to which is
  appended one invented type <i>template-parameter</i> for each occurrence of
  <del><code>auto</code></del><ins>a placeholder</ins>
  in the lambda&rsquo;s <i>parameter-declaration-clause</i>, in
  order of appearance.
  The invented type <i>template-parameter</i> is <del>a template parameter pack if
  the corresponding parameter-declaration declares a function parameter pack</del><ins>formed
  according to the rules for inventing template parameters for an
  abbreviated function template</ins> (9.2.3.5).
  The return type and function parameters of the function call operator template
  are derived from the <i>lambda-expression</i>&rsquo;s <i>trailing-return-type</i>
  and <i>parameter-declaration-clause</i> by replacing each occurrence of
  <code>auto</code> in the <i>decl-specifier</i>s of the
  <i>parameter-declaration-clause</i> with the name of the corresponding
  <i>invented template-parameter</i>. The <i>requires-clause</i> of the function
  call operator template is the <i>requires-clause</i> immediately following
  <code>< <i>template-parameter-list</i> ></code>, if any. The trailing
  <i>requires-clause</i> of the function call operator or operator template is
  the <i>requires-clause</i> following the <i>lambda-declarator</i>, if any.</p>
</blockquote>

<p>
  Update the rules for interpreting <i>return-type-requirement</i>s in
  <i>compound-requirements</i> in [expr.prim.req.compound, 7.5.7.3],
  paragraph 1.
</p>

<blockquote class="std">
<blockquote><pre><code><i>return-type-requirement</i>:
      <i>trailing-return-type</i>
      <del>-&gt; <i>cv-qualifier-seq<sub>opt</sub> constrained-parameter cv-qualifier-seq<sub>opt</sub> abstract-declarator<sub>opt</sub></i></del></code></pre>
</blockquote>

<p>A <i>compound-requirement</i> asserts properties of the expression <code>E</code>.
Substitution of template arguments (if any)
and verification of semantic properties proceed in the following order:</p>
<ul>
  <li>Substitution of template arguments (if any) into the expression is
      performed.</li>
  <li>If the noexcept specifier is present, <code>E</code> shall not be a
      potentially-throwing expression (13.4)</li>
  <li>If the <i>return-type-requirement</i> is present, then:
    <ul>
    <li>Substitution of template arguments (if any) into the
      <i>return-type-requirement</i> is performed.
    <li><del>If the <i>return-type-requirement</i> is a <i>trailing-return-type</i>,
      <code>E</code> is implicitly convertible to the type named by the
      <i>trailing-return-type</i>. If conversion fails, the enclosing
      <i>requires-expression</i> is <code>false</code>.</del></li>
    <li><del>If the <i>return-type-requirement</i> starts with a
      <i>constrained-parameter</i> (12.1), the expression is deduced against
      an invented function template <code>F</code> using the rules in 12.9.2.1.
      <code>F</code> is a <code>void</code> function template with a single
      type template parameter <code>T</code> declared with the
      <i>constrained-parameter</i>. A <i>cv-qualifier-seq</i> <i>cv</i> is
      formed as the union of <code>const</code> and <code>volatile</code>
      specifiers around the <i>constrained-parameter</i>. <code>F</code> has a single parameter whose type-specifier is cv T followed by the abstract-declarator. If deduction fails, the enclosing requires-expression is false.</del></li>

      <li><ins>If the <i>trailing-return-type</i> includes a placeholder... [Merge with P1084]</ins>

      <li><ins>Otherwise, ... [Merge with P1084]</ins></li>
    </ul>
  </li>
</ul>
</blockquote>

<p>Change [9.1.7.2] paragraph 1 to add <i> 5.</i>s.</p>

<blockquote class="std">
<blockquote><pre><code><i>simple-type-specifier</i>:
        <i>nested-name-specifier<sub>opt</sub> type-name</i>
        <i>nested-name-specifier</i> template <i>simple-template-id</i>
        <i>nested-name-specifier<sub>opt</sub> template-name</i>
        char
        char16_t
        char32_t
        wchar_t
        bool
        short
        int
        long
        signed
        unsigned
        float
        double
        void
        auto
        <i>decltype-specifier</i>
        <ins><i>constrained-type-specifier</i></ins></code></pre>
</blockquote>
</blockquote>

<p>Modify paragraph 2 as follows.</p>

<blockquote class="std">
<p>The <i>simple-type-specifier</i> <code>auto</code> <del>is a</del><ins>and
<i>constrained-type-specifier</i>s are</ins> placeholder<ins>s</ins> for<del> a</del>
type<ins>s</ins> to be deduced (9.1.7.4).</p>
</blockquote>

<p>Add <i>constrained-type-specifier</i>s to the table of
<i>simple-type-specifier</i>s and their meaning.</p>

<blockquote class="std">
<table>
<tr><td>Specifier(s)</td><td>Type</td></tr>
<tr><td><i>type-name</i></td><td>the type named</td></tr>
<tr><td><i>simple-template-id</i><td>the as defined in 17.3</td></tr>
<tr><td>...</td><td></td></tr>
<tr><td><code>auto</code><td>placeholder for a type to be deduced</td></tr>
<tr><td><code>decltype(auto)</code><td>placeholder for a type to be deduced</td></tr>
<tr><td><code>decltype(<i>expression</i>)</code><td>the type as described below</td></tr>
<tr><td><ins><i>constrained-type-specifier</i></ins><td><ins>placeholder for a type to be deduced</ins></td></tr>
</table>
</blockquote>

<p>In 9.1.7.4, modify paragraph 1 as follows.</p>

<blockquote class="std">
<p>The <ins><i>type-specifier</i>s </ins><code>auto</code> and <code>decltype(auto)</code>
<del><i>type-specifier</i>s are used to</del><ins>and <i>constrained-type-specifier</i>s</ins>
designate a placeholder type that will be replaced later by deduction from an initializer.
<ins>Types deduced for <i>constrained-type-specifier</i>s must additionally satisfy
a constraint derived from their <i>qualified-concept-name</i>.</ins>
<del>The <code>auto</code> <i>type-specifier</i> is</del><ins>These <i>type-specifier</i>s are</ins>
also used <del>to introduce a function type having a
<i>trailing-return-type</i> or </del>to signify that a lambda is a generic
lambda (7.5.5)<del>.</del><ins>, that a function declaration is an abbreviated
function template (9.2.3.5), or that a <i>trailing-return-type</i> in a
<i>compound-requirement</i> (7.5.7.3) denotes a deduction requirement.</ins>
The <code>auto</code> <i>type-specifier</i> is also used <ins>to introduce a
function type having a <i>trailing-return-type</i> or </ins>to introduce a
structured binding declaration (9.5).</p>
</blockquote>

<p>Modify paragraph 3 as follows.</p>

<blockquote class="std">
<p>The type of a variable declared using <del><code>auto</code> or
<code>decltype(auto)</code></del><ins>a placeholder type</ins> is deduced
from its initializer. This use is allowed in an initializing declaration (9.3)
of a variable. <del><code>auto</code> or <code>decltype(auto)</code></del><ins>The
placeholder type</ins> shall appear as one of the
<i>decl-specifier</i>s in the <i>decl-specifier-seq</i> and the
<i>decl-specifier-seq</i> shall be followed by one or more declarators, each
of which shall be followed by a non-empty initializer.</p>
</blockquote>

<p>Modify paragraph 5 as follows.</p>

<blockquote class="std">
<p>A program that uses <del><code>auto</code> or <code>decltype(auto)</code></del><ins>a
placeholder type</ins> in a context not explicitly allowed in this
subclause is ill-formed.</p>
</blockquote>

<p>In 9.1.7.4.1, modify the last sentence of paragraph 2 as follows.</p>

<blockquote class="std">
<p>In the case of a return statement with no operand or with an operand of type
<code>void</code>, <code>T</code> shall be <del>either </del><code>decltype(auto)</code><ins>,</ins>
<del>or </del><i>cv</i> <code>auto</code><ins>, or
<i>cv constrained-type-specifier</i></ins>.</p>
</blockquote>

<p>Add a new subsection, 9.1.7.4.2.</p>

<blockquote class="stdins">
<h4>9.1.7.4.2 Constrained placeholders [dcl.spec.auto.constr]</h4>

<p>1. A <i>constrained-type-specifier</i> designates a placeholder type and
introduces an associated constraint (17.10.2).

<blockquote><pre><code><i>constrained-type-specifier</i>:
      <i>qualified-concept-name</i> auto
      <i>qualified-concept-name</i> decltype(auto)

<i>qualified-concept-name</i>:
      <i>nested-name-specifier<sub>opt</sub> concept-name</i>
      <i>nested-name-specifier<sub>opt</sub> partial-concept-id</i>

<i>concept-name</i>:
      <i>identifier</i>

<i>partial-concept-id</i>:
      <i>concept-name</i> &lt; <i>template-argument-list<sub>opt</sub></i> &gt;</code></pre>
</blockquote>

<p>[<i>Example</i>:</p>
<blockquote><pre><code>template&lt;typename T&gt; concept C = true;
namespace N {
  template&lt;typename T, typename U&gt; concept C = true;
}

N::C&lt;int&gt; auto x = 42;                   // N::C&lt;int&gt; auto designates a placeholder type;
                                         // x deduced as int
const N::C&lt;int&gt; decltype(auto) y = (x);  // N::C&lt;int&gt; decltype(auto) designates
                                         // a placeholder type; y deduced as int&amp;
void f1(C auto);                         // C designates a placeholder type;
                                         // f1 is an abbreviated function template</code></pre>
</blockquote>
<p>&mdash;<i>end example</i>]</p>

<p>2. An <i>identifier</i> is a <i>concept-name</i> if it refers to a concept
definition (12.6.8). A <i>partial-concept-id</i> is a <i>concept-name</i>
followed by a sequence of <i>template-argument</i>s. The concept designated by a
<i>constrained-type-specifier</i> is that of its <i>concept-name</i>.</p>

<p>3. The meaning of a <i>constrained-type-specifier</i> appearing in the
<i>parameter-type-list</i> of a function declaration is described in 9.2.3.5.
The meaning of a <i>constrained-type-specifier</i> appearing in a non-type
<i>template-parameter</i> is described in 12.1.
The meaning of a <i>constrained-type-specifier</i> appearing in a parameter
of a generic lambda is described in 7.5.5.
The meaning of a <i>constrained-type-specifier</i> appearing in the
<i>trailing-return-type</i> of a <i>compound-requirement</i> is described in
7.5.7.3.
The meaning of a <i>constrained-type-specifier</i> appearing in the
<i>type-specifier-seq</i> of a variable or the declared return type of a
function or lambda are described below.</p>

<p>4. A <i>constrained-type-specifier</i> has an associated
<i>constraint-expression</i> <code>C</code>  that is formed according
to the rules in 12.1.</p>

<p>5. If the <i>constrained-type-specifier</i> has the form
<i>qualified-concept-id</i> <code>auto</code>, the type is deduced
using the rules in 9.1.7.4.1. Otherwise, the
<i>constrained-type-specifier</i> has the form <i>qualified-concept-id</i>
<code>decltype(auto)</code>, and the type is deduced using the rules
in 9.1.7.2.</p>

<p>5. The associated constraint is checked for satisfaction (12.4) after a
replacement type <code>T</code> has been deduced.
To determine if <code>C</code> is satisfied, construct a parameter mapping
from the template arguments in <code>C</code> where that the invented
template argument is replaced by <code>T</code>. That parameter mapping is
applied to normalization of <code>C</code>. If the constraint is not satisfied,
the program is ill-formed.</p>
</blockquote>

<p>Add the following paragraphs to 9.2.3.5.</p>

<blockquote class="stdins">
<p>
1. An <i>abbreviated function template</i> is a function declaration whose
<i>parameter-type-list</i> includes one or more placeholders (9.1.7.4). An
abbreviated function template is equivalent to a function template (17.6.5)
whose <i>template-parameter-list</i> includes one invented type
<i>template-parameter</i> for each occurrence of a placeholder type in the
<i>decl-specifier-seq</i> of a <i>parameter-declaration</i>, in order of
appearance. In particular, for a <i>declarator</i> <code>D</code> and a
<i>qualified-concept-name</i> <code>C</code>, the corresponding
<i>template-parameter</i> is formed using the following rules.</p>
<ul>
  <li>A parameter of the form <code>auto D</code>, has the invented
  <i>template-parameter</i> <code>typename <i>unique_name</i></code>.</li>

  <li>A parameter of the form <code>auto ...D</code>, has the invented
  <i>template-parameter</i> <code>typename ...<i>unique_name</i></code>.</li>

  <li>A parameter of the form <code>C auto D</code>, has the invented
  <i>template-parameter</i> <code>C <i>unique_name</i></code>.</li>

  <li>A parameter of the form <code>C auto ...D</code>, has the invented
  <i>template-parameter</i> <code>C ...<i>unique_name</i></code>.</li>

  <li>A parameter of the form <code>decltype(auto) D</code> or
    <code>C decltype(auto) D</code> is ill-formed.</li>
</ul>
<p>The adjusted function parameters of an abbreviated function template are
derived from the <i>parameter-declaration-clause</i> by replacing each
occurrence of a placeholder with the name of the corresponding invented
<i>template-parameter</i>. If the replacement of a placeholder with the name
of a template parameter results in an invalid parameter declaration, the
program is ill-formed.</p>
<p>[<i>Example</i>:</p>
<blockquote><pre><code>template&lt;typename T&gt;             concept C1 = true;
template&lt;typename T&gt;             concept C2 = true;
template&lt;typename T, typename U&gt; concept C3 = true;
template&lt;typename... Ts&gt;         concept C4 = true;

void g1(const C1 auto*, C2 auto&amp;);
void g3(C1 auto&amp;...);
void g5(C4...);
void g7(C4 p);

template&lt;C1 T, C2 U&gt; void g1(const T*, U&amp;); // redeclaration of g1
template&lt;C1... Ts&gt;   void g3(Ts&amp;...);       // redeclaration of g3
template&lt;C4... Ts&gt;   void g5(Ts...);        // redeclaration of g5
template&lt;C4 T&gt;       void g7(T);            // redeclaration of g7</code></pre></blockquote>
<p>&mdash;<i>end example</i>]</p>

<p>
2. A function template can be an abbreviated function template.
The invented <i>template-parameter</i>s are appended to the
<i>template-parameter-list</i> after the explicitly declared
<i>template-parameter</i>s.
<p>[<i>Example</i>:</p>
<blockquote><pre><code>template&lt;typename&gt; concept C = /* ... */;

template &lt;typename T, C U&gt;
  void g(T x, U y, C auto z);

template&lt;typename T, C U, C W&gt;
  void g(T x, U y, W z);                    // redeclaration of g

template&lt;typename T, typename U, typename W&gt;
  requires C&lt;U&gt; &amp;&amp; C&lt;W&gt;
  void g(T x, U y, W z);                    // redeclaration of g</code></pre></blockquote>
<p>&mdash;<i>end example</i>]</p>
</blockquote>


<h3 id="wordingpt3">For Part 3</h3>

<p>Change [12.1, temp.param] paragraph 1 to update the grammar for
<i>constrained-parameter</i>. </p>

<blockquote class="std">
<blockquote><pre><code><i>constrained-parameter</i>:
      <del><i>qualified-concept-name</i> ... <i>identifier<sub>opt</sub></i></del>
      <del><i>qualified-concept-name identifier<sub>opt</sub> default-template-argument<sub>opt</sub></i></del>
      <ins><i>qualified-concept-name</i></ins>

<del><i>qualified-concept-name</i>:</del>
      <del><i>nested-name-specifier<sub>opt</sub> concept-name nested-name-specifier<sub>opt</sub>partial-concept-id</i></del>

<del><i>partial-concept-id</i>:</del>
      <del><i>concept-name</i> < <i>template-argument-list<sub>opt</sub></i> ></del></code></pre>
</blockquote>
</blockquote>

<p>Change [12.1, temp.param] paragraph 10 as follows.</p>

<blockquote class="std">
<p>
  A <i>constrained-parameter</i> declares a <ins>type</ins> template parameter<del> whose
  kind (type, non-type, template) and type
  match that of the prototype parameter (12.6.8) of the</del><ins>. The</ins> concept designated by the <i>qualified-concept-name</i>
  in the <i>constrained-parameter</i><ins> shall be a type concept (12.6.8)</ins>.
  <del>Let <code>X</code> be the prototype parameter of the designated concept.
  The declared template parameter is determined by the kind of <code>X</code>
  (type, non-type, template)
  and the optional ellipsis in the <i>constrained-parameter</i> as follows.</del>
</p>
<ul class="del">
  <li><del>If <code>X</code> is a type <i>template-parameter</i>,
    the declared parameter is a type <i>template-parameter</i>.</del></li>
  <li><del>If <code>X</code> is a non-type <i>template-parameter</i>,
    the declared parameter is a non-type <i>template-parameter</i>
    having the same type as <code>X</code>.</del></li>
  <li><del>If <code>X</code> is a template <i>template-parameter</i>,
    the declared parameter is a template <i>template-parameter</i>
    having the same <i>template-parameter-list</i> as <code>X</code>,
    excluding default template arguments.</del></li>
  <li>If the <i>qualified-concept-name</i> is followed by an ellipsis,
    then the declared parameter is a template parameter pack (temp.variadic, 12.6.3).</li>
</ul>
<p>[<i>Example</i>:</p>
<blockquote><pre><code>template&lt;typename T&gt; concept C1 = true;
<del>template&lt;template&lt;typename&gt; class X&gt; concept C2 = true;
template&lt;int N&gt; concept C3 = true;</del>
template&lt;typename... Ts&gt; concept <del>C4</del><ins>C2</ins> = true;
<del>template&lt;char... Cs&gt; concept C5 = true;</del>
<ins>template&lt;int N&gt; concept C3 = true;</ins>

template&lt;C1 T&gt; void f1();           // OK, T is a type template-parameter
<del>template&lt;C2 X&gt; void f2();           // OK, X is a template with one type-parameter
template&lt;C3 N&gt; void f3();           // OK, N has type int</del>
template&lt;<del>C4</del><ins>C2</ins>... Ts&gt; void <del>f4</del><ins>f2</ins>();   // OK, Ts is a template parameter pack of types
<del>template&lt;C4 T&gt; void f5();           // OK, T is a type template-parameter
template&lt;C5... Cs&gt; void f6();       // OK, Cs is a template parameter pack of chars</del>
<ins>template&lt;C3 N&gt; void f3();           // error: auto is missing in the constrained-type-specifier
                                    // of a non-type template parameter</ins>
</code>
</pre>
</blockquote>
<p>&mdash;<i>end example</i>]</p>
</blockquote>

<h3 id="wordingpt4">For Part 4</h3>

<p>Change [12.1, temp.param] paragraph 11 as follows.</p>

<blockquote class="std">
<p>
  <del>A</del><ins>Both</ins> <i>constrained-parameter</i><ins>s</ins>
  <ins>and <i>parameter-declaration</i>s whose <i>type-specifier-seq</i>
  includes a <i>constrained-type-specifier</i> (9.1.7.4.2)</ins>
  introduce<del>s a</del> <i>constraint-expression</i><ins>s</ins>.
  The expression is derived from the <i>qualified-concept-name</i> <code>Q</code>
  in the <i>constrained-parameter</i><ins> or <i>type-specifier-seq</i></ins>,
  its designated concept <code>C</code>,
  and the declared template parameter <code>P</code>.</p>
  <ul>
    <li>First, a <del>template argument</del><ins>template-argument</ins>
      <code>A</code> is invented <del>from</del><ins>to match</ins> <code>P</code>
      <ins>in kind (type or non-type)</ins>.
      <del>If <code>P</code> declares a template parameter pack ([temp.variadic])
      and <code>C</code> is a variadic concept ([temp.concept]), then <code>A</code>
      is the pack expansion <code>P...</code>. Otherwise, <code>A</code> is the <i>id-expression</i> <code>P</code></del>.</li>
    <li><del>Then</del><ins>Next</ins>, an <i>id-expression</i> <code>E</code> is formed as follows.
      If <code>Q</code> is a <i>concept-name</i>, then <code>E</code> is <code>C&lt;A&gt;</code>.
      Otherwise, <code>Q</code> is a <i>partial-concept-id</i> of the form <code>C&lt;A1, A2, ..., An&gt;</code>,
      and <code>E</code> is <code>C&lt;A, A1, A2, ..., An&gt;</code>.</li>
    <li>Finally, if <code>P</code> declares a template parameter pack<del> and <code>C</code>
      is not a variadic concept</del>, <code>E</code> is adjusted to be the
      <i>fold-expression</i> <code>(E &amp;&amp; ...)</code> (7.5.6).</li>
  </ul>
  <p><code>E</code> is the introduced <i>constraint-expression</i>.</p>
  <p>[<i>Example</i>:</p>
  <blockquote><pre><code>template&lt;typename T&gt; concept C1 = true;
template&lt;typename... Ts&gt; concept C2 = true;
template&lt;typename T, typename U&gt; concept C3 = true;

template&lt;C1 T&gt; struct s1;          // associates C1&lt;T&gt;
template&lt;C1... T&gt; struct s2;       // associates (C1&lt;T&gt; &amp;&amp; ...)
template&lt;C2... T&gt; struct s3;       // associates <del>C2&lt;T...&gt;</del><ins>(C2&lt;T&gt; &amp;&amp; ...)</ins>
template&lt;C3&lt;int&gt; T&gt; struct s4;     // associates C3&lt;T, int&gt;
<ins>template&lt;C3&lt;int&gt;... T&gt; struct s4;  // associates (C3&lt;T, int&gt; &amp;&amp; ...)</ins></code></pre></blockquote>
  <p>&mdash;<i>end example</i>]</p>
</blockquote>

<p>Change [12.6.8, temp.concept] paragraph 6 as follows.</p>

<blockquote class="std">
<p>The first declared template parameter of a concept definition is its
<i>prototype parameter</i>. <ins>A <i>type concept</i> is a concept whose
prototype parameter is a type <i>template-parameter</i></ins>.<del>A
<i>variadic concept</i> is a concept whose prototype parameter is a template
parameter pack.</del></p>
</blockquote>

</body>
</html>
